{
  "hash": "2c2853c6cea09641605cb048486da7e3",
  "result": {
    "markdown": "---\ntitle: \"Functional Progamming in R with purrr\"\ndescription: |\n  Minimizing repetition with further replication\nauthor: Thomas Mock\ndate: 03-18-2018\nimage: preview.jpg\ncategories:\n  - purrr\n  - tidyverse\n  - statistics\n---\n\n\n\n![](https://i.imgur.com/LIvMxbN.jpg)\n  \nWhen you first started in R you likely were writing simple code to generate one outcome.\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(\"Hello world!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Hello world!\"\n```\n:::\n:::\n::: {.cell}\n\n```{.r .cell-code}\n5 * 6\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 30\n```\n:::\n:::\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, 3, 4, 5)\n```\n:::\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n:::\n\nThis is great, you are learning about strings, math, and vectors in R!\n\nThen you get started with some basic analyses. You want to see if you can find the mean of some numbers.\n\n::: {.cell}\n\n```{.r .cell-code}\nemployee <- c('John Doe','Peter Gynn','Jolie Hope')\nsalary <- c(21000, 23400, 26800)\nstartdate <- as.Date(c('2010-11-1','2008-3-25','2007-3-14'))\n\n# form dataframe and take mean of salary column\nemploy_data <- data.frame(employee, salary, startdate)\nmean(employ_data$salary)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 23733.33\n```\n:::\n:::\n\nEventually you hopefully get exposed to the tidyverse, and you find how this “opinionated collection of R packages designed for data science” makes data analysis in R easier and more readable!\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars %>% \n  group_by(cyl) %>% \n  summarize(mean(mpg))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n    cyl `mean(mpg)`\n  <dbl>       <dbl>\n1     4        26.7\n2     6        19.7\n3     8        15.1\n```\n:::\n:::\n  \nEverything is going great! You’ve likely replaced Excel at this point, and potentially SPSS or some other statistical software suite! But then you run into a problem where you need to use a function repeatedly.\n\nYou could use something like the following code to calculate one-way ANOVAs for some dependent variables and a set independent variable:\n  \n::: {.cell}\n\n```{.r .cell-code}\naov_mpg <- aov(mpg ~ factor(cyl), data = mtcars)\nsummary(aov_mpg)\n\naov_disp <- aov(disp ~ factor(cyll), data = mtcars)\nsummary(aov_disp)\n\naov_hp <- aov(hp ~ factor(cyl), data = mrcars)\nsummry(aov_hpp)\n\naov_wt <- aov(wt ~ factor(cyl), datas = mtcars)\nsummary(aov_wt)\n```\n:::\n\nBut you copy-pasted code 3x, and oops you made some minor misspelling mistakes which throws an error! (The above code leads to errors!)\n\nAlso, what if you realized that you wanted to actually run these ANOVAs for number of gears instead of number of cylinders? You would have to go back and change the `factor(cyl)` call to `factor(gear)` 4x! This is not very efficient, and you’re more likely to end up with mistakes as you have to type everything multiple times!\n  \n*****\n  \nHow about another example.\n\nLet’s calculate the R-squared values for the linear relationship between Weight and Miles per Gallon, according to the number of Cylinders.\n\nI have written code below that does this for 4 cylinder cars from the `mtcars` dataset. This is a worst case scenario, you know some `dplyr` code (`dplyr::filter`), but are not comfortable with the pipe. That’s fine, you accomplish your goal but a lot of coding! You would have to duplicate this code for 6 cylinder and 8 cylinder cars, for even more code…\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n# create df for 4 cylinder cars\ncyl_4 <- filter(mtcars, cyl == 4)\n\n# create a linear model on 4 cyl cars\nlm_4 <- lm(mpg ~ wt, data = cyl_4)\n\n# get the summ\nlm_4_summary <- summary(lm_4)\n\n# get the r.squared value\nlm_4cyl_r_squared <- lm_4_summary[\"r.squared\"]\n\n# check the value\nlm_4cyl_r_squared\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$r.squared\n[1] 0.5086326\n```\n:::\n:::\n  \n  \nAlternatively, you could do the same thing with the pipe. A lot less typing, but to do this for all 3 subsets means we have to copy paste multiple times, so if you end up wanting to do this as a linear model of `mpg ~ disp` in addition to `mpg ~ wt`, you would have to duplicate the code 3 more times and change it 3 more times. This may not seem like a big deal, but eventually is a huge deal once you start to scale up the code (say 10+ times or 100+ times, etc).\n\n::: {.cell width='16'}\n\n```{.r .cell-code}\n# piped analysis\nlm_4cyl_rsquared <- mtcars %>% \n  filter(cyl == 4) %>%\n  lm(mpg ~ wt, data = .) %>% \n  summary() %>% \n  .$\"r.squared\"\n\n#check output\nlm_4cyl_r_squared\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$r.squared\n[1] 0.5086326\n```\n:::\n:::\n  \n  \nTo solve this issue of *minimizing repetition with further replication*, we can dive straight into purrr! To read more about purrr Hadley Wickham recommends the iteration chapter from “R for Data Science” or alternatively you can look at the purrr documentation. Lastly, Jenny Bryan has a great purrr tutorial here. You can load purrr by itself, but it is also loaded as part of the tidyverse library.\n\n![I used to be all meep—meep—PANIC about purrr!!](https://media.giphy.com/media/gwHRYa4dhOdZC/giphy.gif)\n\n\n![now I’m all like map %>% map %>% PARTY!](https://media.giphy.com/media/3rgXBQIDHkFNniTNRu/giphy.gif) \n\npurrr allows you to map functions to data. Appropriately the basic function in purrr is called map()! The map functions transform their input by applying a function to each element and returning a vector the same length as the input.\n\nThe base arguments for map() are:\n.x - list or atomic vector (logical, integer, double/numeric, and character)\n.f - function, formula, or atomic vector\n\nBasically map() takes a function (.f) and applies it to data (.x).\n\nGoing back to our example of grabbing the R-squared from a linear model, we use the following code with purrr.\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars %>%\n  split(.$cyl) %>%\n  map(~ lm(mpg ~ wt, data = .)) %>%\n  map(summary) %>%\n  map_dbl(\"r.squared\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        4         6         8 \n0.5086326 0.4645102 0.4229655 \n```\n:::\n:::\n\nThis generates an output from all 3 of our linear models according to number of cylinders in 5 lines of code! This is the beauty of purrr, efficient scaling of functions!\n\nLet’s break down our linear model R-squared code.\n\nWe take the mtcars dataset, split it into data subsets according to the number of cylinders, apply a linear model of mpg by wt to each subset of data, apply a summary function and then pull out the r.squared value. However, while purrr is readable, we need to cover a few quirks of using it.\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars %>%\n  split(.$cyl) %>%\n  map(~ lm(mpg ~ wt, data = .)) %>%\n  map(summary) %>%\n  map_dbl(\"r.squared\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        4         6         8 \n0.5086326 0.4645102 0.4229655 \n```\n:::\n:::\n\nFor our code here you may have noticed we have a “`.`” placed twice within the code. This is a placeholder for the data, we can see this below. The “`.`” indicate the left-hand side data, or in this case mtcars. Our split call splits the mtcars dataframe into 3 dataframes, each stored within a list. This may seem odd, but it allows map to cycle through our 3 dataframes and replicate the lm() function on each of them individually.\n\n::: {.cell}\n\n```{.r .cell-code}\n# piped version\nmtcars %>% \n  split(.$cyl)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# base R version\nsplit(mtcars, mtcars$cyl)\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n$`4`\n                mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nDatsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nMerc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nFiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nFiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nVolvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\n$`6`\n                mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4      21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag  21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nHornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nValiant        18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nMerc 280       19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C      17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nFerrari Dino   19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\n\n$`8`\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\n```\n:::\n:::\n\nSimilarily, the “`.`” in or first map call is a placeholder for data, but in this case it will cycle through our list of 3 dataframes generated by the previous pipe. You can see that we get a list of 3 `lm()` outputs, we need to map a summary call to each of these to get access to R-squared.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars %>%\n  split(.$cyl) %>%\n  map(~ lm(mpg ~ wt, data = .))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$`4`\n\nCall:\nlm(formula = mpg ~ wt, data = .)\n\nCoefficients:\n(Intercept)           wt  \n     39.571       -5.647  \n\n\n$`6`\n\nCall:\nlm(formula = mpg ~ wt, data = .)\n\nCoefficients:\n(Intercept)           wt  \n      28.41        -2.78  \n\n\n$`8`\n\nCall:\nlm(formula = mpg ~ wt, data = .)\n\nCoefficients:\n(Intercept)           wt  \n     23.868       -2.192  \n```\n:::\n:::\n\nWe next map our summary function to each of the list items to get cleaner outputs with R-squared values. We now have the rest of our statistical output, including p values and R-squared.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars %>%\n  split(.$cyl) %>%\n  map(~ lm(mpg ~ wt, data = .)) %>%\n  map(summary)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$`4`\n\nCall:\nlm(formula = mpg ~ wt, data = .)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-4.1513 -1.9795 -0.6272  1.9299  5.2523 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)   39.571      4.347   9.104 7.77e-06 ***\nwt            -5.647      1.850  -3.052   0.0137 *  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 3.332 on 9 degrees of freedom\nMultiple R-squared:  0.5086,\tAdjusted R-squared:  0.454 \nF-statistic: 9.316 on 1 and 9 DF,  p-value: 0.01374\n\n\n$`6`\n\nCall:\nlm(formula = mpg ~ wt, data = .)\n\nResiduals:\n     Mazda RX4  Mazda RX4 Wag Hornet 4 Drive        Valiant       Merc 280      Merc 280C \n       -0.1250         0.5840         1.9292        -0.6897         0.3547        -1.0453 \n  Ferrari Dino \n       -1.0080 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)   \n(Intercept)   28.409      4.184   6.789  0.00105 **\nwt            -2.780      1.335  -2.083  0.09176 . \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.165 on 5 degrees of freedom\nMultiple R-squared:  0.4645,\tAdjusted R-squared:  0.3574 \nF-statistic: 4.337 on 1 and 5 DF,  p-value: 0.09176\n\n\n$`8`\n\nCall:\nlm(formula = mpg ~ wt, data = .)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-2.1491 -1.4664 -0.8458  1.5711  3.7619 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  23.8680     3.0055   7.942 4.05e-06 ***\nwt           -2.1924     0.7392  -2.966   0.0118 *  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 2.024 on 12 degrees of freedom\nMultiple R-squared:  0.423,\tAdjusted R-squared:  0.3749 \nF-statistic: 8.796 on 1 and 12 DF,  p-value: 0.01179\n```\n:::\n:::\n\nOur last map is a bit different. You can see we use `map_dbl` this time. This indicates we want our output to be a `dbl` or numeric outcome. We get nice named numbers!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars %>%\n  split(.$cyl) %>%\n  map(~ lm(mpg ~ wt, data = .)) %>%\n  map(summary) %>%\n  map_dbl(\"r.squared\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        4         6         8 \n0.5086326 0.4645102 0.4229655 \n```\n:::\n:::\n\n\nIf we had not indicated `map_dbl`, but instead used `map` we would get a list of the same outcome.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars %>%\n  split(.$cyl) %>% \n  map(~ lm(mpg ~ wt, data = .)) %>%\n  map(summary) %>%\n  map(\"r.squared\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$`4`\n[1] 0.5086326\n\n$`6`\n[1] 0.4645102\n\n$`8`\n[1] 0.4229655\n```\n:::\n:::\n\nYou could also use `map_dfr` which binds the outputs into rows of a dataframe.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars %>%\n  split(.$cyl) %>% \n  map(~ lm(mpg ~ wt, data = .)) %>%\n  map(summary) %>%\n  map_dfr(\"r.squared\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 3\n    `4`   `6`   `8`\n  <dbl> <dbl> <dbl>\n1 0.509 0.465 0.423\n```\n:::\n:::\n\nThere are limitless applications of purrr and other functions within purrr that greatly empower your functional programming in R. I hope that this guide motivates you to add purrr to your toolbox and explore this useful tidyverse package!\n\nAs a brief teaser to some more applications of purrr, I’ll leave you with this example. I mentioned calculating ANOVAs across multiple variables at the beginning. Break down this example on your own and see what you think! (You can copy paste this code into R, but need to load the tidyverse and broom packages first).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars %>%\n  mutate(cyl = factor(cyl)) %>%\n  select(mpg, disp, hp) %>%\n  map(~ aov(.x ~ cyl, data = mtcars)) %>%\n  map_dfr(~ broom::tidy(.), .id = 'source') %>%\n  mutate(p.value = round(p.value, 5))\n```\n:::\n\nIn closing, I’d like to thank several `#r4ds` Online Learning Community members for their help in my personal understanding of `purrr`: Frank Farach, Michael Kuehn, and Kent Johnson.\n\nIf you are interested in joining this community led by Jesse Maegan check out her post [here](https://www.jessemaegan.com/post/r4ds-the-next-iteration/)!\n\n:::{.callout-tip collapse=\"true\"}\n## Expand for Session Info\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n─ Session info ───────────────────────────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.1.1 (2021-08-10)\n os       macOS Monterey 12.2.1\n system   aarch64, darwin20\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       America/Chicago\n date     2022-04-25\n pandoc   2.18 @ /Applications/RStudio.app/Contents/MacOS/quarto/bin/tools/ (via rmarkdown)\n quarto   0.9.294 @ /usr/local/bin/quarto\n\n─ Packages ───────────────────────────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n broom       * 0.7.9   2021-07-27 [1] CRAN (R 4.1.0)\n dplyr       * 1.0.8   2022-02-08 [1] CRAN (R 4.1.1)\n forcats     * 0.5.1   2021-01-27 [1] CRAN (R 4.1.1)\n ggplot2     * 3.3.5   2021-06-25 [1] CRAN (R 4.1.1)\n purrr       * 0.3.4   2020-04-17 [1] CRAN (R 4.1.0)\n readr       * 2.0.2   2021-09-27 [1] CRAN (R 4.1.1)\n sessioninfo * 1.2.2   2021-12-06 [1] CRAN (R 4.1.1)\n stringr     * 1.4.0   2019-02-10 [1] CRAN (R 4.1.1)\n tibble      * 3.1.6   2021-11-07 [1] CRAN (R 4.1.1)\n tidyr       * 1.2.0   2022-02-01 [1] CRAN (R 4.1.1)\n tidyverse   * 1.3.1   2021-04-15 [1] CRAN (R 4.1.0)\n\n [1] /Library/Frameworks/R.framework/Versions/4.1-arm64/Resources/library\n\n──────────────────────────────────────────────────────────────────────────────────────────────────\n```\n:::\n:::\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}