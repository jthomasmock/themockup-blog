{
  "hash": "475947341fa80b8e8014a96332d77ee5",
  "result": {
    "markdown": "---\ntitle: \"Bullet Chart Variants in R\"\ndescription: |\n  Efficient display of several measures at once.\nauthor: Thomas Mock\ndate: 11-29-2020\ncategories:\n  - data visualization\n  - tidyverse\n  - ggplot2\n  - nfl\nimage: preview.png\n---\n\n\n\n\n## Bullet Charts\n\nA [bullet chart](https://en.wikipedia.org/wiki/Bullet_graph) is a rich variant of the simple bar chart. Most commonly they can be used to replace \"flashier\" gauges, and are more compact/efficient in their display of multiple measures at once.\n\nClassically they encode a quantitative measure, a qualitative scale, and a comparison or target measure. \n\n::: {.cell}\n::: {.cell-output-display}\n![Figure from [Stephen Few via Wikipedia](https://en.wikipedia.org/wiki/Bullet_graph)](https://upload.wikimedia.org/wikipedia/commons/thumb/9/9a/Labelled_Bullet_Graph_Example.svg/500px-Labelled_Bullet_Graph_Example.svg.png){class=external}\n:::\n:::\n\nThe original design of bullet charts can be given to [Stephen Few](http://www.perceptualedge.com/articles/misc/Bullet_Graph_Design_Spec.pdf), and the above image is from his blog - [perceptualedge.com](http://www.perceptualedge.com).\n\nOthers have tried some various strategies to robustly graph these with `ggplot2` - notably [Bob Rudis' `Rbulletgraph`](https://github.com/hrbrmstr/Rbulletgraph) and Ryo Nakagawara/Amit Kohli's [`bulletchartr`](https://ryo-n7.github.io/2018-04-30-bulletchartr-package-experience/), and my own [`geom_bullet`](https://github.com/jthomasmock/tomtom). \n\nIt's a hard problem to solve with a *general* function, given that often the bullet charts don't typically adhere nicely to a single data frame and tidy-data principles, typically require re-factoring of the input data or external reference data, or at the least require multiple columns to be charted.\n\nMy personal attempts are very much modeled after Bob's approach, which is layering graph components as opposed a single `geom_` call. \n\nThe `bulletchartr` approach on the other hand (which is relatively similar to my `geom_bullet()`) is to create a function that takes a summary data frame and plots several columns from the data. \n\n::: {.cell}\n\n```{.r .cell-code}\nbulletchartr::bullet_chart(dataframe = bc_ex)\n```\n:::\n\n::: {.cell .column-column-page-inset}\n::: {.cell-output-display}\n![](test_bullet.png){width=2502}\n:::\n:::\n\nThis is a fine approach for an opinionated take on bullet charts, but I'll focus on building your own from scratch in case you only want some of the features.\n\n## Component Parts\n\nWe can break down the bullet chart into the comparative range and the quantitative measure. Thus we can approximate the chart by overlaying 2x `geom_col()` calls in `ggplot2`.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n::: {.cell fig.dim='[6,2]'}\n\n```{.r .cell-code}\ntibble(\n  name = \"Example\",\n  quant_value = 75,\n  qualitative = 100\n) %>% \n  ggplot(aes(x = quant_value, y = name)) +\n  geom_col(aes(x = qualitative), fill = \"grey\") +\n  geom_col(width = 0.5, fill = \"black\") +\n  coord_cartesian(ylim = c(0.3, 1.7)) +\n  theme_minimal() +\n  theme(panel.grid.major.y = element_blank())\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=576}\n:::\n:::\n\nAlternatively, we can do it in one call if the data is arranged in a longer format.\n\n::: {.cell fig.dim='[8,2]'}\n\n```{.r .cell-code}\nex_df <- tibble(\n  name = rep(\"Example\", 2),\n  group = c(\"Qualitative\", \"Measure\"),\n  value = c(100, 75),\n  width = c(0.9, 0.5)\n)\nex_df %>% \n  ggplot(aes(x = value, y = name, fill = group)) +\n  geom_col(width = ex_df$width) +\n  coord_cartesian(ylim = c(0.3, 1.7)) +\n  scale_fill_manual(values = c(\"black\", \"grey\")) +\n  theme_minimal() +\n  theme(panel.grid.major.y = element_blank())\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=768}\n:::\n:::\n\n## Add a target\n\nNext we can also include a target measure. At this point you can see that we're really stretching what is reasonable for one dataset, as we're duplicating a lot of values that don't really need to be duplicated. We could store this outside or indicate them manually but again you can see why this can in theory be generalized, but it's complex.\n\n::: {.cell fig.dim='[6,4]'}\n\n```{.r .cell-code}\nex_df <- bind_rows(\n  tibble(\n  name = rep(\"Ex 1\", 2),\n  group = c(\"Qualitative\", \"Measure\"),\n  color = c(\"grey\", \"black\"),\n  value = c(100, 75),\n  width = c(0.9, 0.5),\n  target = rep(82, 2),\n  ymin = rep(0.7, 2),\n  ymax = rep(1.3, 2)\n  ),\n  tibble(\n  name = rep(\"Ex 2\", 2),\n  group = c(\"Qualitative\", \"Measure\"),\n  color = c(\"grey\", \"black\"),\n  value = c(88, 64),\n  width = c(0.9, 0.5),\n  target = rep(77, 2),\n  ymin = rep(1.7, 2),\n  ymax = rep(2.3, 2)\n  )\n)\n\nex_df %>% \n  ggplot(aes(x = value, y = name, fill = color)) +\n  geom_col(width = c(0.9, 0.5, 0.9, 0.5)) +\n  geom_linerange(\n    aes(x = target, ymin = ymin, ymax = ymax),\n    size = 2, color = \"red\"\n    ) +\n  coord_cartesian(ylim = c(0.3, 2.7)) +\n  scale_fill_identity() +\n  theme_minimal() +\n  theme(panel.grid.major.y = element_blank())\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=576}\n:::\n:::\n\n## Add qualitative ranges\n\nThe next layer of complexity arises around the idea of creating more qualitative ranges (ie poor, good, great). I've hidden the code in an expandable section due to the length, but it's all there! This is an example from an [older `#TidyTuesday` plot](https://twitter.com/thomas_mock/status/1184121610216886279) I did in 2019.\n\n<details><summary>Full Code</summary>\n\n::: {.cell hash='index_cache/html/unnamed-chunk-8_b911d90985ec7bb2254806dbbcd730a3'}\n\n```{.r .cell-code}\nbig_epa_cars <- readr::read_csv(\"https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2019/2019-10-15/big_epa_cars.csv\")\n\ncars_clean <- big_epa_cars %>%\n  janitor::clean_names()\n\nrange_cars <- cars_clean %>%\n  filter(!is.na(eng_dscr)) %>%\n  filter(year == 2018) %>%\n  summarize(\n    q50 = quantile(highway08, probs = 0.50),\n    q95 = quantile(highway08, probs = 0.95),\n    q100 = quantile(highway08, probs = 1.00)\n  )\n\ntop_cars <- cars_clean %>%\n  filter(!is.na(eng_dscr)) %>%\n  filter(year == 2018) %>%\n  group_by(make) %>%\n  top_n(1, city08) %>%\n  ungroup() %>%\n  filter(make %in% c(\n    \"Subaru\",\n    \"Volvo\",\n    \"Chevrolet\",\n    \"Ford\",\n    \"Mazda\",\n    \"Honda\",\n    \"Toyota\",\n    \"Volkswagen\"\n  )) %>%\n  distinct(make, .keep_all = TRUE) %>%\n  select(make, model, highway08, city08, eng_dscr, year) %>%\n  arrange(desc(highway08), city08) %>%\n  mutate(\n    eng_type = if_else(\n      str_detect(eng_dscr, \"PHEV|Hybrid\"), \n      \"Hybrid\", \"Gas\"\n      )\n    ) %>%\n  mutate(make_model = paste(make, eng_type, sep = \" - \"))\n\nmpg_levels <- top_cars %>%\n  arrange(desc(highway08), city08) %>%\n  pull(make_model)\n\nplot_cars <- top_cars %>%\n  mutate(\n    min_mpg = pull(range_cars, q50),\n    middle_mpg = pull(range_cars, q95),\n    max_mpg = pull(range_cars, q100)\n  ) %>%\n  mutate(make_model = factor(make_model, levels = rev(mpg_levels)))\n\nbar_cars <- plot_cars %>%\n  distinct(make, .keep_all = TRUE)\n\ncar_plot <- bar_cars %>%\n  ggplot() +\n  geom_col(\n    aes(x = make_model, y = max_mpg),\n    fill = \"#A9A9A9\",\n    width = 0.6,\n    alpha = 0.9\n  ) +\n  geom_col(\n    aes(x = make_model, y = middle_mpg),\n    fill = \"#808080\",\n    width = 0.6,\n    alpha = 0.9\n  ) +\n  geom_col(\n    aes(x = make_model, y = min_mpg),\n    fill = \"#696969\",\n    width = 0.6,\n    alpha = 0.9\n  ) +\n  geom_col(\n    aes(x = make_model, y = highway08),\n    fill = \"black\",\n    color = NA,\n    width = 0.2\n  ) +\n  geom_errorbar(\n    aes(x = make_model, ymin = city08, ymax = city08),\n    color = \"red\",\n    width = 0.45,\n    size = 2\n  ) +\n  coord_flip() +\n  theme_minimal() +\n  labs(\n    x = \"\",\n    y = \"\\nMiles per Gallon\",\n    title = \"Some hybrids are more efficient in the <span style='color:#FF0000'>**City**</span> than <span style='color:#000000'>**Highway**</span>\",\n    subtitle = \"Typically, vehicles are more efficient on the highway\"\n  ) +\n  theme(\n    panel.grid = element_blank(),\n    plot.title = element_markdown(),\n    axis.text = element_text(face = \"bold\")\n  ) +\n  annotate(\n    \"text\",\n    x = c(rep((8 + .45), 4)),\n    y = c(\n      bar_cars$min_mpg[1] * 0.5,\n      bar_cars$middle_mpg[1] * 0.85,\n      bar_cars$max_mpg[1] * 0.8,\n      bar_cars$city08[1]\n    ),\n    label = c(\"Poor\", \"Good\", \"Great\", \"City\"),\n    color = c(rep(\"black\", 3), \"red\")\n  ) +\n  scale_y_continuous(breaks = seq(0, 60, 10)) +\n  NULL\n```\n:::\n\n</details>\n\n::: {.cell .column-column-page-inset}\n\n```{.r .cell-code}\ncar_plot\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=768}\n:::\n:::\n\nAt this point, we've essentially recreated the approach of things like `geom_bullet()` or `bulletchartr`. As you can see this is a bit of work, but once you have the rough structure setup you could create or use a function (like `bulletchartr`t) or a `geom_` like `geom_bullet()`.\n\n## The buried lede\n\nThe whole reason I got started on this post was my interest in re-creating ESPN's Playoff Probablity Leverage from Brian Burke's team. He outlined the process in a [nice Twitter thread](https://twitter.com/bburkeESPN/status/1331755980175052803?s=20).\n\n<blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">Almost forgot. These leverage graphs get a lot of love here for some reason, on a site where that&#39;s rare. So I&#39;m going to thread a tale of how they came to be... <a href=\"https://t.co/0O5fnRxVpu\">pic.twitter.com/0O5fnRxVpu</a></p>&mdash; Brian Burke (@bburkeESPN) <a href=\"https://twitter.com/bburkeESPN/status/1331755980175052803?ref_src=twsrc%5Etfw\">November 26, 2020</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nNumber one, these are gorgeous, and I really loved the addition of an example legend rather than a long description, which Brian Burke also noted was an extremly simple explanation of a relatively complex chart. Additionally, he mentioned that they were automated, which is always a driving force for why code is useful!\n\n<blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">I should note that Matt devised the &quot;key&quot; at the bottom of the charts that puts the 100 words in my original text box (&quot;This chart depicts...blah blah...&quot;) into the world&#39;s best succinct graphical explainer: <a href=\"https://t.co/tjhbY0XNRn\">pic.twitter.com/tjhbY0XNRn</a></p>&mdash; Brian Burke (@bburkeESPN) <a href=\"https://twitter.com/bburkeESPN/status/1331766737017200643?ref_src=twsrc%5Etfw\">November 26, 2020</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nWe can pretty quickly recreate the basic concept as seen below. Note that I have some additional data collection steps that we'll go over in just a second.\n\n::: {.cell hash='index_cache/html/get-data_ee275a8e2394d6f56c5ea78f4655f970'}\n\n:::\n\n::: {.cell .column-column-page-inset}\n\n```{.r .cell-code}\nteam_df %>%\n  ggplot(aes(x = win_cur, y = fct_reorder(abb_name, win_pct))) +\n  geom_col(aes(x = 100), fill=\"white\", color = \"grey\", width = 0.7) +\n  geom_col(aes(x = win_pct), alpha = 0.5, width = 0.7) +\n  geom_col(width = 0.7) +\n  labs(x = \"Win Probability\", y = \"\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\nWe could make these more \"bullet-chart-y\" by altering the width of the columns, but I honestly think the stacked/alpha approach is more appealing here given the amount of variables. Also, since we're showing the minimal range and then the potential achievement (leverage) I think the stack is more appropriate than a classical bullet. Regardless, both can work and I'll leave it up to the reader to decide which is more informative.\n\n::: {.cell .column-column-page-inset}\n\n```{.r .cell-code}\nteam_df %>%\n  ggplot(aes(x = win_cur, y = fct_reorder(abb_name, win_pct))) +\n  geom_col(aes(x = 100), fill=\"white\", color = \"grey\", width = 0.7) +\n  geom_col(aes(x = win_pct), alpha = 0.5, width = 0.7) +\n  geom_col(width = 0.3) +\n  labs(x = \"Win Probability\", y = \"\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\nSo the next step is to add in team colors, replace team names with logos, and add the explanatory legend.\n\n## Data Collection\n\nI'm going to be getting team standings, colors and logos from my own `espnscrapeR`. Also, to cheat I'm not going to do the 20K simulations that ESPN and many others do to create the underlying data, but rather \"borrow\" the data from the original chart. Note I'm also loading [`patchwork`](https://patchwork.data-imaginist.com/) for combining plots, and [`ggtext`](https://github.com/wilkelab/ggtext) to use for the team logos on the axis. Lastly, I'm using a few custom fonts which I'll load via the [`systemfonts`](https://github.com/r-lib/systemfonts) package.\n\n::: {.cell hash='index_cache/html/get-data_31b16aba2ace0375d47c655bdc1f0653'}\n\n```{.r .cell-code}\nlibrary(ggtext)\nlibrary(systemfonts)\nlibrary(patchwork)\n\nteams <- espnscrapeR::get_nfl_standings(2020)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nReturning 2020\n```\n:::\n\n```{.r .cell-code}\nteam_meta <- espnscrapeR::get_nfl_teams() %>% \n  select(abb_name = team_abb, team_color)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nGetting NFL teams!\n```\n:::\n\n```{.r .cell-code}\nteam_df <- teams %>% \n  select(abb_name = team_abb, logos = team_logo, playoff_seed = seed) %>% \n  left_join(team_meta) %>% \n  group_by(playoff_seed) %>% \n  mutate(\n    count = row_number(),\n    conf = if_else(count == 1, \"AFC\", \"NFC\")) %>% \n  ungroup() %>% \n  filter(conf == \"AFC\") %>% \n  mutate(\n    win_cur = c(\n      99, 99, 81, 60, 73, 59, 52, 59, 16, 1, 3, 1, 1, 1, 0, 0\n    ),\n    win_pct = c(\n    99,99.01,94, 91, 95, 83, 69, 86, 39, 3, 13, 1, 1,1,1, 0\n    ),\n    win_chg = round(win_pct - win_cur, 1)\n  ) %>% \n  mutate(\n    abb_name = factor(abb_name),\n    abb_name = fct_reorder(abb_name, win_pct, .desc = TRUE),\n    abb_name = fct_rev(abb_name)\n  ) %>% \n  arrange(desc(win_pct))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining, by = \"abb_name\"\n```\n:::\n:::\n\nI've also defined a function to take the logo url and convert it to a HTML `<img>` tag which `ggtext` can then plot in `ggplot2` for us!\n\n::: {.cell}\n\n```{.r .cell-code}\nlink_to_img <- function(x, width = 30) {\n  glue::glue(\"<img src='{x}' width='{width}'/>\")\n}\n```\n:::\n\n## Plot with colors/logos\n\nI'm really pleased with this, as it's a very close approximation of the original, and Brian Burke did a great job on the original aesthetics. We still need to create the legend plot and then \"attach\" it to the bottom of this plot. We can combine the plots with `patchwork`, but first let's try building it!\n\n::: {.cell hash='index_cache/html/unnamed-chunk-13_177c5c4586a60baea78ebd5e0001efb6'}\n\n```{.r .cell-code}\nteam_logo_plot <- team_df %>%\n  mutate(logos = link_to_img(logos)) %>% \n  ggplot(aes(x = win_cur, y = fct_reorder(logos, win_pct), fill = team_color)) +\n  geom_text(\n    aes(x = 100, label = paste0(win_chg, \"%\")), \n    nudge_x = 6, hjust = 1, fontface= \"bold\", family = \"Chivo\", size = 6\n    ) +\n  geom_col(aes(x = 100), fill=\"white\", color = \"grey\", width = 0.7) +\n  geom_col(aes(x = win_pct), alpha = 0.5, width = 0.7) +\n  geom_col(width = 0.7) +\n  scale_fill_identity() +\n  scale_x_continuous(breaks = c(25, 50, 75), labels = scales::percent_format(scale = 1)) +\n  theme_minimal() +\n  theme(\n    text = element_text(family = \"Chivo\"),\n    panel.grid.major.y = element_blank(),\n    panel.grid.minor = element_blank(),\n    panel.grid.major.x = element_line(color = \"grey\", size = 0.2),\n    panel.ontop = TRUE,\n    axis.text.y = element_markdown(margin = margin(r = -25, unit = \"pt\")),\n    axis.text.x = element_text(size = 16, color = \"grey\"),\n    plot.title = element_text(size = 36, face = \"bold\"),\n    plot.subtitle = element_text(size = 24),\n    plot.margin = unit(c(0.5, 1.5, 0.5, 1.5), \"cm\")\n  ) +\n  labs(\n    x = \"\", y = \"\", \n    title = \"Playoff Probability Leverage\",\n    subtitle = \"AFC Week 12\"\n  )\n```\n:::\n\n::: {.cell .column-column-page-inset}\n::: {.cell-output-display}\n![](team_logo_prob.png){width=1920}\n:::\n:::\n\n\n## Create a legend\n\nI'm going to be creating a few dataframes to plot in my legend. These include labels, and some \"segments\" to create the lines around the labels.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Core dataset with the basic labels\nlabel_df <- tibble(\n  x = c(15, 15, 77, 101),\n  y = c(1.6, 0.35, 0.35, 1),\n  label = c(\"Chance to make playoffs with win \", \"Chance to make playoffs with loss \", \"Leverage\", \"X%\")\n)\n\n\n# the horizontal lines\nseg_df <- tibble(\n  x1 = c(0.2, 90, 0.2, 74.8, 75.3, 90, 103),\n  x2 = c(0.2, 90, 0.2, 74.8, 75.3, 90, 103),\n  y1 = c(1.3, 1.3, rep(.7, 5)),\n  y2 = c(1.61, 1.61, rep(.343, 5))\n\n)\n\n# vertical lines\nseg2_df <- tibble(\n  x1 = c(0.2, 0.2, 75.3),\n  x2 = c(90, 74.8, 103),\n  y1 = c(1.6, .35, .35),\n  y2 = c(1.6, .35, .35)\n)\n```\n:::\n\nThe first plot is very simple, and close to our examples at the very beginning of this post!\n\n::: {.cell fig.dim='[6,2]'}\n\n```{.r .cell-code}\nlegend_plot <- tibble(\n  x = 75,\n  y = factor(\"Y\"),\n  x2 = 90\n) %>%\n  ggplot(aes(x = x, y = y)) +\n  geom_col(aes(x = 100), fill = \"white\", color = \"grey\", width = 0.4) +\n  geom_col(aes(x = x2), width = 0.4, color = \"#DC143C\", fill = \"grey\") +\n  geom_col(width = 0.4, color = \"black\", fill = \"black\")\n\nlegend_plot\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=576}\n:::\n:::\n\nYou'll notice a few things. Since our y-axis is a factor it's essentially an integer where `Y == 1`. Each additional factor will be placed at `N + 1`\n\n::: {.cell fig.dim='[6,2]'}\n\n```{.r .cell-code}\nlegend_plot +\n  geom_text(aes(x = 50, y = 1, label = \"Label at 1\"), color = \"red\", size = 8) +\n  geom_text(aes(x = 50, y = 1.5, label = \"Label at 1.5\"), color = \"red\", size = 8)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){width=576}\n:::\n:::\n\nSince we can place labels above or below or measure of interest, we can use that concept to create line segments via `geom_segment()` at specific locations. You will notice that there is some ovelap/overplotting of the lines - I do this so that there isn't a gap when things are blown up a bit in the final graph.\n\nWe can add in the horizontal/vertical lines by two `geom_segment` layers. \n\n::: {.cell fig.dim='[6,2]'}\n\n```{.r .cell-code}\nlegend_plot <- tibble(\n  x = 75,\n  y = factor(\"Y\"),\n  x2 = 90\n) %>%\n  ggplot(aes(x = x, y = y)) +\n  geom_col(aes(x = 100), fill = \"white\", color = \"grey\", width = 0.4) +\n  geom_col(aes(x = x2), width = 0.4, color = \"#DC143C\", fill = \"grey\") +\n  geom_col(width = 0.4, color = \"black\", fill = \"black\") +\n  geom_segment(\n    data = seg_df,\n    aes(x = x1, y = y1, xend = x2, yend = y2),\n    color = c(rep(\"black\", 4), rep(\"#DC143C\", 3)),\n    size = 1\n  ) +\n  geom_segment(\n    data = seg2_df,\n    aes(x = x1, y = y1, xend = x2, yend = y2),\n    color = c(\"black\", \"black\", \"#DC143C\"),\n    size = 1\n  ) \n\nlegend_plot\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){width=576}\n:::\n:::\n\nOur final step will be to add the text/labels in, and make sure they have a white background to \"hide\" the lines behind them.\n\n::: {.cell .column-column-page-inset fig.dim='[12,4]'}\n\n```{.r .cell-code}\nfinal_legend <- legend_plot +\n  geom_label(\n    data = label_df,\n    aes(x = x, y = y, label = label),\n    hjust = 0, size = 8, fontface = \"bold\", fill = \"white\",\n    color = c(\"black\", \"black\", \"#DC143C\", \"#DC143C\"),\n    label.size = NA,\n    family = \"Oswald\",\n    label.padding = unit(0.05, \"lines\"),\n  ) +\n  coord_cartesian(ylim = c(0.7, 1.2), xlim = c(0, 108)) +\n  theme_void() +\n  theme(\n    plot.margin = unit(c(0.5, 1.5, 0.5, 1.5), \"cm\"),\n    plot.caption = element_markdown(size = 14)\n    )  +\n  labs(\n    caption = \"<br><br>**Plot**: @thomas_mock | **Inspiration**: @bburkeESPN\"\n  )\n\nfinal_legend\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-1.png){width=1152}\n:::\n:::\n\n## Combine the plots\n\nNow that both plots are done, we can very quickly combine them with `patchwork`. `patchwork` provides additional capabilities for layout/combining plots.\n\nWe can read the code below as `plot1` over `plot2` and then height of `plot1 == 5`, height of `plot2 == 1`.\n\n::: {.cell}\n\n```{.r .cell-code}\ncombo_plot <- team_logo_plot / legend_plot + plot_layout(heights = c(5,1))\n```\n:::\n\n::: {.cell .column-column-page-inset}\n::: {.cell-output-display}\n![](combo_plot.png){width=1920}\n:::\n:::\n\nAnd that's it! We've recreated Brian Burke's example in R, and figured out how to make some custom legends and combine them together.\n\n## Another example\n\nBen Baldwin also had another tweet that inspired me to apply a similar concept. The full code snippet I used is on [GitHub](https://git.io/JkNfu). Here, Ben is comparing the Actual and Expected Pass Frequency over/under expected with a lollipop chart. Given that we're comparing ranges I thought a bullet chart would be a nice alternative!\n\n<blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">This is since week 7, whew boy <a href=\"https://t.co/O40sdbbtDA\">pic.twitter.com/O40sdbbtDA</a></p>&mdash; Computer Cowboy (@benbbaldwin) <a href=\"https://twitter.com/benbbaldwin/status/1332732996030517251?ref_src=twsrc%5Etfw\">November 28, 2020</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nThe part to note here is we are now comparing one measure to another, as opposed to the theoretical value + the minimal value we saw in the ESPN example. I also used *almost* the same code as above, but now the `actual` passing frequency bar is thinner than the `expected` passing range.\n\n<details><summary>Full Code</summary>\n\n::: {.cell hash='index_cache/html/unnamed-chunk-22_ed0f617d4564563f693273727f67fb06'}\n\n```{.r .cell-code}\nlibrary(patchwork)\nlibrary(ggtext)\n\nteam_colors <- nflfastR::teams_colors_logos %>% filter(team_abbr == \"TEN\") %>% \n  select(team_color, team_color2) %>% \n  unlist()\n\n# approximated data\nrun_df <- tibble(\n  down_distance = c(\n    \"1st & 10\",\n    \"2nd & 8+\",\n    \"2nd & 3-7\",\n    \"2nd & 1-2\",\n    \"3rd & 3+\",\n    \"3rd & 1-2\",\n    \"After pass for 1st\",\n    \"After rush for 1st\",\n    \"All plays\"\n  ),\n  actual = c(\n    38, 57, 63, 36, 89, 50, 39, 41, 54\n  ),\n  expected = c(\n    56, 72, 66, 39, 92, 54, 54, 57, 64\n  )\n) %>% \n  mutate(\n    down_distance = factor(down_distance),\n    difference = actual - expected,\n    diff_color = if_else(difference < 0, \"#DC143C\", \"black\")\n    )\n\nrun_plot <- run_df %>%\n  ggplot(aes(x = actual, y = fct_rev(down_distance))) +\n  geom_text(\n    aes(x = 100, label = paste0(difference, \"%\"), color = diff_color), \n    nudge_x = 10, hjust = 1, fontface= \"bold\", family = \"Chivo\", size = 10\n  ) +\n  geom_col(aes(x = 100), width = 0.7, color = \"grey\", alpha = 0.2) +\n  geom_col(aes(x = expected), fill = team_colors[1], alpha = 0.5, width = 0.7) +\n  geom_col(width = 0.3, fill = team_colors[2]) + \n  scale_fill_identity() +\n  scale_x_continuous(breaks = c(25, 50, 75), labels = scales::percent_format(scale = 1)) +\n  theme_minimal() +\n  theme(\n    text = element_text(family = \"Chivo\"),\n    panel.grid.major.y = element_blank(),\n    panel.grid.minor = element_blank(),\n    panel.grid.major.x = element_line(color = \"grey\", size = 0.2),\n    panel.ontop = TRUE,\n    axis.text.y = element_markdown(size = 14, margin = margin(r = -25, unit = \"pt\")),\n    axis.text.x = element_text(size = 16, color = \"grey\"),\n    plot.title = element_markdown(size = 36, face = \"bold\"),\n    plot.subtitle = element_text(size = 24),\n    plot.margin = unit(c(0.5, 1.5, 0.5, 1.5), \"cm\"),\n    legend.position = \"none\"\n  ) +\n  labs(\n    x = \"\", y = \"\", \n    title = glue::glue(\"Titans <span style='color:{team_colors[2]}'>Pass Frequency</span> under <span style='color:{team_colors[1]}'>Expected</span>, 2020\")\n  )\n\n\n# Legend plot -------------------------------------------------------------\n\n\nlabel_df <- tibble(\n  x = c(15, 15, 77, 101),\n  y = c(1.6, 0.35, 0.35, 1),\n  label = c(\"Expected Pass Frequency \", \"Actual Pass Frequency \", \"Difference\", \"X%\")\n)\n\nseg_df <- tibble(\n  x1 = c(0.2, 90, 0.2, 74.8, 75.3, 90, 103),\n  x2 = c(0.2, 90, 0.2, 74.8, 75.3, 90, 103),\n  y1 = c(1.3, 1.3, rep(.7, 5)),\n  y2 = c(1.61, 1.61, rep(.343, 5))\n  \n)\n\nseg2_df <- tibble(\n  x1 = c(0.2, 0.2, 75.3),\n  x2 = c(90, 74.8, 103),\n  y1 = c(1.6, .35, .35),\n  y2 = c(1.6, .35, .35)\n)\n\nlegend_plot <- tibble(\n  x = 75,\n  y = factor(\"Y\"),\n  x2 = 90\n) %>%\n  ggplot(aes(x = x, y = y)) +\n  geom_col(aes(x = 100), fill = \"white\", color = \"grey\", width = 0.4) +\n  geom_col(aes(x = x2), width = 0.4, fill = \"black\", alpha = 0.5) +\n  geom_col(width = 0.2, color = \"black\", fill = \"black\") +\n  geom_segment(\n    data = seg_df,\n    aes(x = x1, y = y1, xend = x2, yend = y2),\n    color = c(rep(\"black\", 4), rep(\"#DC143C\", 3)),\n    size = 1\n  ) +\n  geom_segment(\n    data = seg2_df,\n    aes(x = x1, y = y1, xend = x2, yend = y2),\n    color = c(\"black\", \"black\", \"#DC143C\"),\n    size = 1\n  ) +\n  geom_label(\n    data = label_df,\n    aes(x = x, y = y, label = label),\n    hjust = 0, size = 8, fontface = \"bold\", fill = \"white\",\n    color = c(\"black\", \"black\", \"#DC143C\", \"#DC143C\"),\n    label.size = NA,\n    family = \"Oswald\",\n    label.padding = unit(0.05, \"lines\"),\n  ) +\n  theme_void() +\n  theme(\n    plot.margin = unit(c(0.5, 1.5, 0.5, 1.5), \"cm\"),\n    plot.caption = element_markdown(size = 14)\n  ) +\n  coord_cartesian(ylim = c(0.7, 1.2), xlim = c(0, 108)) +\n  labs(\n    caption = \"<br><br>**Plot**: @thomas_mock | **Inspiration**: @bburkeESPN\"\n  )\n\nlegend_plot\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n\n```{.r .cell-code}\ncombo_plot <- run_plot / legend_plot + plot_layout(heights = c(5,1))\n\ncombo_plot\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-22-2.png){width=672}\n:::\n\n```{.r .cell-code}\n# ggsave(\"ten_rush.png\", combo_plot, height = 14, width = 16, units = \"in\", dpi = \"retina\")\n```\n:::\n\n\n</details>\n\n::: {.cell .column-column-page-inset}\n::: {.cell-output-display}\n![](ten_rush.png){width=2560}\n:::\n:::\n\n:::{.callout-tip collapse=\"true\"}\n## Expand for Session Info\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.2.0 (2022-04-22)\n os       macOS Monterey 12.2.1\n system   aarch64, darwin20\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       America/Chicago\n date     2022-04-28\n pandoc   2.18 @ /Applications/RStudio.app/Contents/MacOS/quarto/bin/tools/ (via rmarkdown)\n quarto   0.9.294 @ /usr/local/bin/quarto\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package      * version    date (UTC) lib source\n bulletchartr * 0.3.1      2022-04-28 [1] Github (ACDIVOCATech/bulletchartr@4725088)\n dplyr        * 1.0.8      2022-02-08 [1] CRAN (R 4.2.0)\n forcats      * 0.5.1      2021-01-27 [1] CRAN (R 4.2.0)\n ggplot2      * 3.3.5      2021-06-25 [1] CRAN (R 4.2.0)\n ggtext       * 0.1.1      2020-12-17 [1] CRAN (R 4.2.0)\n patchwork    * 1.1.0.9000 2022-04-26 [1] Github (thomasp85/patchwork@79223d3)\n purrr        * 0.3.4      2020-04-17 [1] CRAN (R 4.2.0)\n readr        * 2.1.2      2022-01-30 [1] CRAN (R 4.2.0)\n sessioninfo  * 1.2.2      2021-12-06 [1] CRAN (R 4.2.0)\n stringr      * 1.4.0      2019-02-10 [1] CRAN (R 4.2.0)\n systemfonts  * 1.0.4      2022-02-11 [1] CRAN (R 4.2.0)\n tibble       * 3.1.6      2021-11-07 [1] CRAN (R 4.2.0)\n tidyr        * 1.2.0      2022-02-01 [1] CRAN (R 4.2.0)\n tidyverse    * 1.3.1      2021-04-15 [1] CRAN (R 4.2.0)\n\n [1] /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n:::\n:::\n\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}