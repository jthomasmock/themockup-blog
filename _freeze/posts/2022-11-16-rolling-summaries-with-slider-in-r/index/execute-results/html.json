{
  "hash": "9ef1c36561a94d3636f6feeaa8dca0fc",
  "result": {
    "markdown": "---\ntitle: \"Rolling summaries with {slider} in R\"\ndescription: |\n  Slip and slide with the tidyverse\nauthor: Tom Mock\ndate: 2022-11-16\nimage: preview.png\nexecute: \n  cache: true\n---\n\n\nI have been a big fan of the `{slider}` package for a long time! It recently had a CRAN release for v0.3 - check out the package documentation at <https://slider.r-lib.org/news/index.html>.\n\nWhile it is a useful tool for any time series or rolling summary analysis, I'll demo an example with some sports data. \n\n## Libraries and data\n\nWe'll use `{nflreadr}` to load the nflfastR database, along with the `{tidyverse}` and `{slider}` itself.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-1_b3affee635b127de715ef18e66e6ae44'}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching packages ────────────────────────────────── tidyverse 1.3.2.9000 ──\n✔ ggplot2   3.4.0      ✔ dplyr     1.0.10\n✔ tibble    3.1.8      ✔ stringr   1.4.1 \n✔ tidyr     1.2.1      ✔ forcats   0.5.1 \n✔ readr     2.1.3      ✔ lubridate 1.8.0 \n✔ purrr     0.3.5      \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n```\n:::\n\n```{.r .cell-code}\nlibrary(nflreadr)\nlibrary(slider)\nlibrary(ggridges)\nlibrary(ggtext)\n\n# load the years when Mahomes has been active\npbp_db <- nflreadr::load_pbp(2017:2022)\n```\n:::\n\n\n## Filter the data\n\nWe'll limit ourselves to some of the top QBs in the NFL.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-2_57b054bb5aca70ab56e0a5aa82eb478d'}\n\n```{.r .cell-code}\nqb_names <- c(\n  \"P.Mahomes\",\n  \"A.Rodgers\",\n  \"J.Allen\",\n  \"D.Prescott\",\n  \"R.Tannehill\",\n  \"D.Carr\",\n  \"R.Wilson\",\n  \"T.Brady\",\n  \"M.Stafford\",\n  \"L.Jackson\",\n  \"M.Ryan\",\n  \"K.Cousins\"\n)\n```\n:::\n\n\nAnd then figure out the last date/week:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-3_e6d720d072542de9d0ab4a41cd4cb7e4'}\n\n```{.r .cell-code}\ncur_date <- pbp_db |> \n  filter(passer_player_name ==\"P.Mahomes\") |> \n  distinct(game_date, .keep_all = TRUE) |> \n  slice_max(game_date, n = 1) |> \n  select(game_date, week, season)\n```\n:::\n\n\nAnd then get the values of interest for these specific QBs.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-4_025777abc299a898148231ce05593120'}\n\n```{.r .cell-code}\nqb_tops <- pbp_db %>%\n  filter(\n    !is.na(epa),\n    play_type %in% c(\"pass\", \"run\")\n  ) %>%\n  filter(\n    passer_player_name %in% qb_names |\n      rusher_player_name %in% qb_names,\n  ) %>%\n  mutate(\n    name = if_else(\n      is.na(passer_player_name), \n      rusher_player_name, \n      passer_player_name\n      )\n    ) %>%\n  select(name, posteam, defteam, season, game_id, epa)\n\nglimpse(qb_tops)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 39,188\nColumns: 6\n$ name    <chr> \"M.Stafford\", \"M.Stafford\", \"M.Stafford\", \"M.Stafford\", \"M.Sta…\n$ posteam <chr> \"DET\", \"DET\", \"DET\", \"DET\", \"DET\", \"DET\", \"DET\", \"DET\", \"DET\",…\n$ defteam <chr> \"ARI\", \"ARI\", \"ARI\", \"ARI\", \"ARI\", \"ARI\", \"ARI\", \"ARI\", \"ARI\",…\n$ season  <int> 2017, 2017, 2017, 2017, 2017, 2017, 2017, 2017, 2017, 2017, 20…\n$ game_id <chr> \"2017_01_ARI_DET\", \"2017_01_ARI_DET\", \"2017_01_ARI_DET\", \"2017…\n$ epa     <dbl> -11.6032015, -0.5463381, -1.5034251, -1.7764411, -0.1084029, -…\n```\n:::\n:::\n\n\nThe data is now ready for some analysis! We hae the player's name, season, game_id and their EPA (expected points added).\n\n## Slide across values\n\nAt a basic level, the `slide_` functions allow you to reference a specific row along with previous rows (lagging) and the next rows (leading).\n\nI find this most useful for rolling summarizing functions such as rolling means. From the `{slider}` docs:\n\n> slider is a package for rolling analysis using window functions. “Window functions” is a term that I’ve borrowed from SQL that means that some function is repeatedly applied to different “windows” of your data as you step through it. Typical examples of applications of window functions include rolling averages, cumulative sums, and more complex things such as rolling regressions.\n\nMost typically, this will be used within an existing dataframe, but let's show a quick example on a vector.\n\nWe can return a list of equal length to the input, that accumulates the 2 values before it. Note that it _slides_ across the values and won't return more than the 3 requested (row + 2 rows before).\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-5_90a990e96af693b2a4d8ffe07273d1d0'}\n\n```{.r .cell-code}\nslide(1:4, ~.x, .before = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1\n\n[[2]]\n[1] 1 2\n\n[[3]]\n[1] 1 2 3\n\n[[4]]\n[1] 2 3 4\n```\n:::\n:::\n\n\nOr more realistically, we can generate the rolling mean of the current row and up to two rows before. Note that I've now used `slide_dbl()` - similar to `{purrr}` there is specific type safety, and you specify what you want to return (character, dbl, list as default, etc).\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-6_2296db65ab5b24b4174cd1f0ff1ae9c7'}\n\n```{.r .cell-code}\nslide_dbl(1:4, mean, .before = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.0 1.5 2.0 3.0\n```\n:::\n:::\n\n\nThis is basically equivalent to the below:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-7_46b3f96de7ef2b294cda16344cbe953d'}\n\n```{.r .cell-code}\nc(\n  mean(1),\n  mean(1:2),\n  mean(1:3),\n  mean(2:4)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.0 1.5 2.0 3.0\n```\n:::\n:::\n\n\nI also want to callout the `.complete` argument:\n\n> Should the function be evaluated on complete windows only? If FALSE, the default, then partial computations will be allowed.\n\n`.complete = TRUE` will only generate complete computations of the current row and the specific `.before` or `.after` amount. See below where we need at least 3 observations to generate the mean, and the first two calculations return NA (since they are length 1 and length 2, respectively.)\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-8_5224cee7c48211089634dfe6c2907153'}\n\n```{.r .cell-code}\nslide_dbl(1:4, mean, .before = 2, .complete = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA NA  2  3\n```\n:::\n:::\n\n\nKind of like the below (but again much more safety/power in `{slider}`):\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-9_4f67398841a248570740625fedace523'}\n\n```{.r .cell-code}\nc(\n  ifelse(length(1)   == 3, mean(1),   NA),\n  ifelse(length(1:2) == 3, mean(1:2), NA),\n  ifelse(length(1:3) == 3, mean(1:3), NA),\n  ifelse(length(2:4) == 3, mean(2:4), NA)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA NA  2  3\n```\n:::\n:::\n\n\n## Slide across rows\n\nNow vectors are fine, but we want to use it in a dataframe, across \"windows\" in a specific column. \n\nWe can read the below code as:\n- For each quarterback\n- Calculate the rolling average of EPA\n- Of the current row, and the 99 previous rows\n- and only for `.complete` windows - so it will return NA for windows < 100\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-10_63b15ea996457017597c7e1afb281132'}\n\n```{.r .cell-code}\ntest_slide <- qb_tops %>%\n  group_by(name) %>%\n  summarize(\n    slide_mean = slide_dbl(\n      .x = epa, .f = mean, \n      .before = 99L, .complete = TRUE\n      ),\n  )\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'name'. You can override using the\n`.groups` argument.\n```\n:::\n\n```{.r .cell-code}\ntest_slide\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 39,188 × 2\n# Groups:   name [12]\n   name      slide_mean\n   <chr>          <dbl>\n 1 A.Rodgers         NA\n 2 A.Rodgers         NA\n 3 A.Rodgers         NA\n 4 A.Rodgers         NA\n 5 A.Rodgers         NA\n 6 A.Rodgers         NA\n 7 A.Rodgers         NA\n 8 A.Rodgers         NA\n 9 A.Rodgers         NA\n10 A.Rodgers         NA\n# … with 39,178 more rows\n```\n:::\n:::\n\n\nNotice that the first few rows are all NA since we have specified `.complete = TRUE`. For our analysis, we'll want to exclude NA values after.\n\nWe can calculate the rolling mean and a lot more!\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-11_b6e377b1b0b5a525cbeb358162aa45fb'}\n\n```{.r .cell-code}\nqb_sum <- qb_tops %>%\n  group_by(name) %>%\n  summarize(\n    slide_mean = slide_dbl(.x = epa, .f = mean, .before = 99L, .complete = TRUE),\n    slide_median = slide_dbl(.x = epa, .f = median, .before = 99L, .complete = TRUE),\n    slide_sum = slide_dbl(.x = epa, .f = sum, .before = 99L, .complete = TRUE),\n    absolute_median = median(epa),\n    absolute_mean = mean(epa),\n    absolute_sum = sum(epa),\n    posteam = tail(posteam, n = 1)\n  ) %>%\n  ungroup() %>%\n  filter(!is.na(slide_mean)) %>%\n  # sort by the overall best median\n  arrange(desc(absolute_median))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'name'. You can override using the\n`.groups` argument.\n```\n:::\n\n```{.r .cell-code}\nqb_sum |> glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 38,000\nColumns: 8\n$ name            <chr> \"P.Mahomes\", \"P.Mahomes\", \"P.Mahomes\", \"P.Mahomes\", \"P…\n$ slide_mean      <dbl> 0.4677885, 0.4682522, 0.5148074, 0.4598741, 0.4597226,…\n$ slide_median    <dbl> 0.2908019, 0.2908019, 0.3427478, 0.2908019, 0.2908019,…\n$ slide_sum       <dbl> 46.77885, 46.82522, 51.48074, 45.98741, 45.97226, 45.7…\n$ absolute_median <dbl> 0.1340611, 0.1340611, 0.1340611, 0.1340611, 0.1340611,…\n$ absolute_mean   <dbl> 0.2810101, 0.2810101, 0.2810101, 0.2810101, 0.2810101,…\n$ absolute_sum    <dbl> 993.6518, 993.6518, 993.6518, 993.6518, 993.6518, 993.…\n$ posteam         <chr> \"KC\", \"KC\", \"KC\", \"KC\", \"KC\", \"KC\", \"KC\", \"KC\", \"KC\", …\n```\n:::\n:::\n\n\n## Plot the rolling mean\n\nWe can then plot the distribution of the rolling mean. First we'll generate a vector of colors to use for names and then join the team colors to the QB dataframe for plotting.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-12_6e864c1abfb1a1dc27d56707b5d1b70d'}\n\n```{.r .cell-code}\nname_colors <- if_else(\n  unique(qb_sum$name) == \"P.Mahomes\", \n  \"#e31837\", \n  \"black\"\n  ) %>% rev()\n\ndens_df <- qb_sum %>%\n  group_by(name) %>%\n  mutate(\n    median_of_slides = median(slide_mean),\n    fill_color = if_else(name == \"P.Mahomes\", \"#e31837\", \"grey\"),\n    out_color = if_else(name == \"P.Mahomes\", \"#e31837\", \"white\")\n  ) %>%\n  ungroup() %>%\n  left_join(\n    nflfastR::teams_colors_logos %>% select(posteam = team_abbr, team_color),\n    by = \"posteam\"\n  )\n```\n:::\n\n\nThen we can arrange the data by the overall median, create density ridgelines, and add some context.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-13_b9e12fdf82529aed0f25340453d4cbdd'}\n\n```{.r .cell-code}\nmahomes_plot <- dens_df %>%\n  ggplot(\n    aes(\n      x = slide_mean,\n      y = fct_reorder(name, median_of_slides, .desc = FALSE),\n      fill = team_color\n    )\n  ) +\n  geom_density_ridges(\n    quantile_lines = TRUE,\n    quantiles = 2,\n    color = \"#f0f0f0\",\n    size = 0.5\n  ) +\n  geom_vline(xintercept = 0, linewidth = 1, alpha = 0.5) +\n  coord_cartesian(xlim = c(-0.3, 0.65)) +\n  theme_minimal() +\n  scale_fill_identity(aesthetics = c(\"fill\", \"color\")) +\n  scale_x_continuous(breaks = scales::pretty_breaks(n = 8)) +\n  labs(\n    x = \"Rolling 100 play mean EPA\",\n    y = \"\",\n    caption = \"\\n**Plot**: @thomas_mock | **Data**: nflfastR\",\n    title = \"Mahomes doesn't have bad streaks\",\n    subtitle = glue::glue(\"Distribution of rolling 100 play average passing/running EPA,\\nthrough Week {cur_date$week} of {cur_date$season}\")\n  ) +\n  tomtom::theme_538() +\n  theme(\n    axis.text.y = element_text(\n      color = name_colors,\n      face = c(rep(\"plain\", 16), \"bold\"),\n      size = 14,\n      vjust = 0\n    ),\n    panel.grid.major.y = element_blank(),\n    panel.grid.minor = element_blank(),\n    plot.caption = element_markdown(size = 12),\n    plot.background = element_rect(fill = \"white\", color = \"white\")\n  )\n\nmahomes_plot\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=768}\n:::\n:::\n\n\n\n:::{.callout-tip collapse=\"true\"}\n## Expand for Session Info\n::: {.cell hash='index_cache/html/unnamed-chunk-15_c1ea33440f128a7ef9866ca75ef9a6a7'}\n::: {.cell-output .cell-output-stdout}\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.2.0 (2022-04-22)\n os       macOS Monterey 12.6\n system   aarch64, darwin20\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       America/Chicago\n date     2022-11-17\n pandoc   2.19.2 @ /Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/ (via rmarkdown)\n quarto   1.2.242 @ /usr/local/bin/quarto\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version    date (UTC) lib source\n dplyr       * 1.0.10     2022-09-01 [1] CRAN (R 4.2.0)\n forcats     * 0.5.1      2021-01-27 [1] CRAN (R 4.2.0)\n ggplot2     * 3.4.0      2022-11-04 [1] CRAN (R 4.2.0)\n ggridges    * 0.5.3      2021-01-08 [1] CRAN (R 4.2.0)\n ggtext      * 0.1.1      2022-09-14 [1] Github (wilkelab/ggtext@50fdaba)\n lubridate   * 1.8.0      2021-10-07 [1] CRAN (R 4.2.0)\n nflreadr    * 1.3.0      2022-08-06 [1] CRAN (R 4.2.0)\n purrr       * 0.3.5      2022-10-06 [1] CRAN (R 4.2.0)\n readr       * 2.1.3      2022-10-01 [1] CRAN (R 4.2.0)\n sessioninfo * 1.2.2      2021-12-06 [1] CRAN (R 4.2.0)\n slider      * 0.2.2      2021-07-01 [1] CRAN (R 4.2.0)\n stringr     * 1.4.1      2022-08-20 [1] CRAN (R 4.2.0)\n tibble      * 3.1.8      2022-07-22 [1] CRAN (R 4.2.0)\n tidyr       * 1.2.1      2022-09-08 [1] CRAN (R 4.2.0)\n tidyverse   * 1.3.2.9000 2022-08-16 [1] Github (tidyverse/tidyverse@3be8283)\n\n [1] /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n:::\n:::\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}