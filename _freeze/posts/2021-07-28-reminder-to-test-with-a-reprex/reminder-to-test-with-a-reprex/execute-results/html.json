{
  "hash": "b1224416d03a28e53b952c5e7c888a16",
  "result": {
    "markdown": "---\ntitle: \"Reminder to test with a reprex\"\ndescription: |\n  \"It's basically the rubber duck in disguise\" - Jenny Bryan.\nauthor: Thomas Mock\ndate: 07-28-2021\npreview: preview.jpeg\ncategories:\n  - meta\n  - reprex\n  - tidyverse\n---\n\n\n\n\nIt's been a while since my last post, so I wanted to get back into the swing of things with a shorter article. My goal was to get a new one up on the blog before August 1st.\n\nAs such, I was working late on a *much* longer form article and as part of this I wanted to display some smoothed lines for several players on one plot. A sneak peek of some of this below:\n\n![A 3x3 grid facetted by quarter of the observation number on the X axis and the rolling max, min, and average on the Y-axis.](plot9-qb.png)\nNow, I've been programming in R for quite some time, but for the life of me I couldn't get my facets to align properly. This led to a bit of frustration as I \"knew\" what I was doing *should be right* but wasn't returning the expected \"correct\" output. \n\nThis article walks through why I believe [`{reprex}`](https://reprex.tidyverse.org/index.html) driven testing is so useful for compartmentalizing a problem and getting at the specifics of why our expectation sometimes don't match the output.\n\nLike most useful ideas, I'm far from the first person to think of it!\n\n<blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">Iâ€™ve decided that preparing a reprex is, in fact, a very effective technique for solving your own problems<br><br>itâ€™s basically the rubber duck in disguise</p>&mdash; Jenny Bryan (@JennyBryan) <a href=\"https://twitter.com/JennyBryan/status/948971918266281985?ref_src=twsrc%5Etfw\">January 4, 2018</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\n<blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">My problem-solving workflow:<br><br>1. ðŸ¤¬ somethingâ€™s wrong with this pkg<br>2. Iâ€™m gonna open a GitHub issue<br>3. Wait, I need to add a reprex<br>4. Oohhhhhh ðŸ’¡<br>5. Problem solved âœ… <a href=\"https://t.co/8GVJvR71YL\">https://t.co/8GVJvR71YL</a></p>&mdash; Garrick Aden-Buie (@grrrck) <a href=\"https://twitter.com/grrrck/status/1406307933969948676?ref_src=twsrc%5Etfw\">June 19, 2021</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\n<blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">Software engineering research question: if people are required to create a short reproducible example (reprex) when filing a bug, how often does doing that result in them solving their own problem?</p>&mdash; Greg Wilson (@gvwilson) <a href=\"https://twitter.com/gvwilson/status/1363893685209956362?ref_src=twsrc%5Etfw\">February 22, 2021</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nThat's a few folks who I have a great deal of respect for, and as usual they have great advice for us! (Write a `reprex` and you'll likely solve the problem as you go)\n\n## Who's problem is this?\n\nNow whenever I run into errors, mistakes, or unexpected outputs I ask myself:  \n\n> Is this a \"Tom\" problem? Or is this R's fault?\n\n![Principle skinner out of touch meme, with the text \"Is it my code that is wrong?\" and \"No it must be an error with the forcats package\" overlaid.](skinner-wrong.jpeg)\n\nThe short answer is that it's almost always a \"me\" problem, as R is just diligently following the commands I gave to it. However, in some *rare* cases I do find a bug and can use the `{reprex}` testing I've done to quickly log a useful a bug report for the package developers.\n\nIf you haven't run into the term \"reprex\" before, it is a:  \n\n> \"minimal **repr**oducible **ex**ample\"\n\nYou can read more about the [`{reprex}` package](https://reprex.tidyverse.org/index.html) on the package documentation [site](https://reprex.tidyverse.org/index.html).\n\n> If youâ€™re asking for R help, reporting a bug, or requesting a new feature, youâ€™re more likely to succeed if you include a good reprex.\n\nThat quote is from the `{reprex}` docs, and I'll add to it that a reprex can help with you solving your *own* problems **BEFORE** even submitting the bug request!\n\n## The Goal\n\nWhile writing the article, I wanted to create a scatter plot, and facet the players by their respective QBR (Quarterback ratings) average scores. However, I kept getting the players to `facet_wrap()` by somewhat of an alphabetical order instead of in descending ranked order. This was a hint that my factor ordering via `{forcats}` was not being respected. I have included the \"wrong\" plot below.\n\n![A 3x3 grid facetted by quarterback of the observation number on the X axis and the rolling max, min, and average on the Y-axis. The quarterbacks are facetted according to their alphabetical names.](plot9-qb-wrong.png)\n\nThis was of course frustrating, so I started doing some testing/troubleshooting of the complex plot as it was.\n\n## Initiate testing\n\nLet's reproduce the initial problem. We'll load the necessary packages, bring in the data, and generate the respective dataframes/plots as well. I'm intentionally leaving the code without comments and as a single code chunk as this is supposed to be a bit like a random code review. In retrospect the error is quite clear to me, but I was honestly stumped for a good chunk of time. \n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(slider)\nlibrary(tidyverse)\nlibrary(espnscrapeR)\n\nall_qbr <- crossing(season = 2018:2020, week = 1:17) %>% \n  pmap_dfr(get_nfl_qbr)\n\nall_college_qbr <- 2018:2020 %>% \n  map_dfr(~get_college_qbr(.x, type = \"weekly\"))\n\ntest_data <- all_qbr %>%\n  select(player_id, qbr = qbr_total, team_abb, short_name) %>%\n  mutate(pure_avg = mean(qbr)) %>%\n  group_by(player_id) %>%\n  filter(n() >= 30) %>% \n  mutate(\n    short_name = fct_reorder(short_name, qbr, .fun= mean, .desc = TRUE),\n    grp_avg = mean(qbr, na.rm = TRUE),\n    diff_avg = qbr - pure_avg,\n    roll_mean = slide_dbl(qbr, mean, .before = 8L),\n    roll_max = slide_dbl(roll_mean, max, .before = Inf),\n    roll_min = slide_dbl(roll_mean, min, .before = Inf),\n    row = row_number()\n  ) %>% \n  ungroup()\n\ntest_plot <- test_data %>% \n  filter(grp_avg >= 62) %>% \n  ggplot(aes(x = row, y = roll_max)) +\n  geom_point(aes(y = qbr), alpha = 0.2) +\n  geom_step() +\n  geom_step(aes(y = roll_min), color = \"red\") +\n  geom_line(aes(y = roll_mean), color = \"blue\") +\n  geom_smooth(aes(y = qbr),method = \"loess\", size = 0.5, span = 0.35) +\n  facet_wrap(~factor(short_name)) +\n  coord_cartesian(ylim = c(0, 105), xlim = c(0, 50), expand = FALSE)\n\ntest_plot\n```\n:::\n\n![A 3x3 grid facetted by quarterback of the observation number on the X axis and the rolling max, min, and average on the Y-axis. The quarterbacks are facetted according to their alphabetical names.](plot9-qb-wrong.png)\n\n### Maybe it's a factor thing?\n\nMy initial thought is \"it seems the factors are not being represented correctly\". Since I'm using `forcats::fct_reorder(.f = short_name, .x = qbr, .fun = mean, .desc = TRUE)` the Quarterback names should respect the \"ranking\" by their respective descending average QBR. \n\nHowever, what I was getting out in `{ggplot2}` is ordered as below. It's not in any real order!\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_data %>% \n  filter(grp_avg >= 62) %>% \n  distinct(short_name, grp_avg) %>% \n  arrange(short_name)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 Ã— 2\n  short_name        grp_avg\n  <fct>               <dbl>\n1 R. Wilson            66.4\n2 T. Brady             63.0\n3 D. Prescott          62.9\n4 D. Brees             71.4\n5 D. Watson            63.4\n6 P. Mahomes           77.2\n7 L. Jackson           68.4\n8 B. Roethlisberger    62.6\n9 A. Rodgers           62.1\n```\n:::\n:::\n\nWhat I wanted, and how it \"should\" arrange like below:  \n\n::: {.cell}\n\n```{.r .cell-code}\ntest_data %>% \n  filter(grp_avg >= 62) %>% \n  mutate(short_name = fct_reorder(short_name, qbr, .fun = mean, .desc = TRUE)) %>% \n  distinct(short_name, grp_avg) %>% \n  arrange(short_name)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 Ã— 2\n  short_name        grp_avg\n  <fct>               <dbl>\n1 P. Mahomes           77.2\n2 D. Brees             71.4\n3 L. Jackson           68.4\n4 R. Wilson            66.4\n5 D. Watson            63.4\n6 T. Brady             63.0\n7 D. Prescott          62.9\n8 B. Roethlisberger    62.6\n9 A. Rodgers           62.1\n```\n:::\n:::\n\nSo let's take a look at the `test_data` object. The factors are simply \"wrong\"! We know we're looking for \"P. Mahomes\" to always lead our rankings in this dataset. The results below are not in any \"real\" order!\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_data %>% \n  filter(grp_avg >= 62) %>% \n  distinct(short_name) %>% \n  arrange(short_name) %>% \n  pull() %>% \n  levels()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"M. Ryan\"           \"M. Stafford\"       \"C. Newton\"        \n [4] \"A. Dalton\"         \"R. Tannehill\"      \"K. Cousins\"       \n [7] \"R. Wilson\"         \"D. Carr\"           \"T. Brady\"         \n[10] \"C. Wentz\"          \"D. Prescott\"       \"D. Brees\"         \n[13] \"M. Trubisky\"       \"J. Goff\"           \"B. Mayfield\"      \n[16] \"D. Watson\"         \"P. Mahomes\"        \"S. Darnold\"       \n[19] \"L. Jackson\"        \"K. Murray\"         \"J. Allen\"         \n[22] \"P. Rivers\"         \"B. Roethlisberger\" \"A. Rodgers\"       \n```\n:::\n:::\n\nI thought to try to correct it manually. I could just get a vector of the quarterbacks according to the ranking and then apply it with `factor(short_names, levels = qb_lvls)`. This gets us the \"right\" order of the names BUT it doesn't really solve our underlying problem or tell us why it's not working out as expected. This is a \"bandaid\" instead of a \"cure\" to my problem! If I did that I would never know if I had a wrong mental model, if there was an actual bug in `{ggplot2}` or `{forcats}` (unlikely), or if I was simply coding it all wrong.\n\n::: {.cell}\n\n```{.r .cell-code}\nqb_lvls <- test_data %>% \n  group_by(short_name) %>% \n  distinct(grp_avg) %>%\n  arrange(desc(grp_avg)) %>% \n  pull(short_name) %>% \n  as.character()\n\nqb_lvls\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"P. Mahomes\"        \"D. Brees\"          \"L. Jackson\"       \n [4] \"R. Wilson\"         \"D. Watson\"         \"T. Brady\"         \n [7] \"D. Prescott\"       \"B. Roethlisberger\" \"A. Rodgers\"       \n[10] \"M. Ryan\"           \"M. Stafford\"       \"J. Allen\"         \n[13] \"P. Rivers\"         \"K. Murray\"         \"R. Tannehill\"     \n[16] \"K. Cousins\"        \"B. Mayfield\"       \"D. Carr\"          \n[19] \"J. Goff\"           \"C. Wentz\"          \"M. Trubisky\"      \n[22] \"A. Dalton\"         \"C. Newton\"         \"S. Darnold\"       \n```\n:::\n:::\n\n### Make a reprex\n\nSo far, I dove into a few troubleshooting steps but it didn't clarify what my underlying problem was. What I should have done was create a reprex or break the problem down into smaller pieces! I was about to ask for some help, so I wanted to generate a `reprex` to use as the \"ask\".\n\nNow for the `reprex`, I don't want to include data scraped from the internet as the data doesn't really matter (and it requires a separate package - `espnscrapeR`). So let's simulate data!\n\n::: {.cell hash='reminder-to-test-with-a-reprex_cache/html/unnamed-chunk-6_290e75f4f45479c7916a3713d40ae6db'}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\nset.seed(20210728)\n\nsim_data <- crossing(\n  grp = letters[1:4],\n  series = 1:10\n) %>% \n  mutate(\n    val = rnorm(n = nrow(cur_data()), mean = 70, sd = 8)\n  )\n\nsim_data\n```\n\n::: {.cell-output-stdout}\n```\n# A tibble: 40 Ã— 3\n   grp   series   val\n   <chr>  <int> <dbl>\n 1 a          1  63.5\n 2 a          2  82.0\n 3 a          3  75.6\n 4 a          4  64.8\n 5 a          5  72.7\n 6 a          6  74.2\n 7 a          7  75.0\n 8 a          8  70.3\n 9 a          9  69.2\n10 a         10  69.7\n# â€¦ with 30 more rows\n```\n:::\n:::\n\nWe also don't need ALL the calculations we are doing, so let's simplify it to just the minimal calculation:  \n- a grouped average  \n- an ordered factor according to that grouped average  \n\n::: {.cell}\n\n```{.r .cell-code}\nsim_plot_df <- sim_data %>% \n  group_by(grp) %>% \n  mutate(\n    grp_avg = mean(val, na.rm = TRUE),\n    grp_fct = fct_reorder(grp, val, .fun = mean, .desc = TRUE)\n  ) %>% \n  ungroup()\n\nsim_plot_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 40 Ã— 5\n   grp   series   val grp_avg grp_fct\n   <chr>  <int> <dbl>   <dbl> <fct>  \n 1 a          1  63.5    71.7 a      \n 2 a          2  82.0    71.7 a      \n 3 a          3  75.6    71.7 a      \n 4 a          4  64.8    71.7 a      \n 5 a          5  72.7    71.7 a      \n 6 a          6  74.2    71.7 a      \n 7 a          7  75.0    71.7 a      \n 8 a          8  70.3    71.7 a      \n 9 a          9  69.2    71.7 a      \n10 a         10  69.7    71.7 a      \n# â€¦ with 30 more rows\n```\n:::\n:::\n\nLet's check what the order _should_ be - looks like `c > a > d > b`\n\n::: {.cell}\n\n```{.r .cell-code}\nsim_plot_df %>% \n  distinct(grp, grp_avg) %>% \n  arrange(desc(grp_avg))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 Ã— 2\n  grp   grp_avg\n  <chr>   <dbl>\n1 c        72.7\n2 a        71.7\n3 d        71.0\n4 b        67.4\n```\n:::\n:::\n\nNow, let's confirm what are the returned levels?\n\n::: {.cell}\n\n```{.r .cell-code}\nsim_plot_df %>% \n  pull(grp_fct) %>% \n  levels()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\" \"b\" \"c\" \"d\"\n```\n:::\n:::\n\nOur `reprex` returned the \"wrong\" values! At this point, I thought I had legitimately found a bug...but I wanted to go one step further and check the plotting. I went ahead and added back in some complexity to check myself - specifically adding a horizontal line to indicate the group average and a label of the actual numeric group average on each facet.\n\nSTILL WRONG!\n\n::: {.cell}\n\n```{.r .cell-code}\nsim_plot_df %>% \n  ggplot(aes(x = series, y = val)) +\n  geom_point() +\n  geom_hline(aes(yintercept = grp_avg), color = \"red\") +\n  geom_text(aes(x = 2.5, y = 100, label = round(grp_avg, digits = 1))) +\n  facet_wrap(~grp_fct, ncol = 4) \n```\n\n::: {.cell-output-display}\n![](reminder-to-test-with-a-reprex_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\nLast step was to confirm I could get `{ggplot2}` to return the expected behavior of `c > a > d > b`. I _could_ get the \"right\" behavior by adding in the `fct_reorder()` across the *overall data* inside `facet_wrap()`.\n\n::: {.cell}\n\n```{.r .cell-code}\nsim_plot_df %>% \n  ggplot(aes(x = series, y = val)) +\n  geom_point() +\n  geom_smooth() +\n  geom_hline(aes(yintercept = grp_avg), color = \"red\") +\n  geom_text(aes(x = 2.5, y = 100, label = round(grp_avg, digits = 1))) +\n  facet_wrap(~fct_reorder(grp_fct, val, .fun = mean, .desc = TRUE), ncol = 4) \n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`geom_smooth()` using method = 'loess' and formula 'y ~ x'\n```\n:::\n\n::: {.cell-output-display}\n![](reminder-to-test-with-a-reprex_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\nAt this point the answer stared me right in the face!\n\n> I _could_ get the \"right\" behavior by adding in the `fct_reorder()` across the **overall data** inside `facet_wrap()`.\n\nEmphasis there added on \"**overall data**\". In my `group_by` + `mutate` I was applying a factor transformation WITHIN each group so each factor was basically a factor with *only* 1 level (the specific group), and when combined back into the dataframe it returned an overall factor with levels simply according to the order of the rows in the data.\n\nHere's a peek at the initial `reprex`.\n\n::: {.cell}\n\n```{.r .cell-code}\nsim_plot_df <- sim_data %>% \n  group_by(grp) %>% \n  mutate(\n    grp_avg = mean(val, na.rm = TRUE),\n    # this should be done BEFORE grouping\n    grp_fct = fct_reorder(grp, val, .fun = mean, .desc = TRUE)\n  ) %>% \n  ungroup()\n```\n:::\n\nand now after I've moved the `fct_reorder()` ahead of the `group_by()`.\n\n::: {.cell}\n\n```{.r .cell-code}\nsim_plot_df_fixed <- sim_data %>% \n  # fct_reorder done BEFORE grouping\n  mutate(grp_fct = fct_reorder(grp, val, .fun = mean, .desc = TRUE)) %>% \n  group_by(grp) %>% \n  mutate(\n    grp_avg = mean(val, na.rm = TRUE)\n  ) %>% \n  ungroup()\n\nsim_plot_df_fixed %>% \n  ggplot(aes(x = series, y = val)) +\n  geom_point() +\n  geom_hline(aes(yintercept = grp_avg), color = \"red\") +\n  geom_text(aes(x = 2.5, y = 100, label = round(grp_avg, digits = 1))) +\n  facet_wrap(~fct_reorder(grp_fct, val, .fun = mean, .desc = TRUE), ncol = 4) \n```\n\n::: {.cell-output-display}\n![](reminder-to-test-with-a-reprex_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\nBy breaking the problem down into the simplest version of itself, and carefully checking my assumptions as I went, I was able to get at the root of the problem.\n\nIn essence by preparing the `reprex` in preparation of asking for help, I was able to solve the problem. \n\nIn the words of [Jenny Bryan](https://twitter.com/JennyBryan/status/948971918266281985?s=20):  \n\n> itâ€™s basically the [rubber duck](https://en.wikipedia.org/wiki/Rubber_duck_debugging#:~:text=In%20software%20engineering%2C%20rubber%20duck,%2Dline%2C%20to%20the%20duck.) in disguise\n\n![A Giant floating yellow rubber duck in the ocean outside Hong Kong](https://images.unsplash.com/photo-1601829534265-66684bd4dcc6?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=1567&q=80)\n\n:::{.aside}\n[Rubber duck debugging according to Wikipedia](https://en.wikipedia.org/wiki/Rubber_duck_debugging)\n\n> In software engineering, rubber duck debugging is a method of debugging code. The name is a reference to a story in the book The Pragmatic Programmer in which a programmer would carry around a rubber duck and debug their code by forcing themselves to explain it, line-by-line, to the duck.\n\n:::\n\nSo go out, create your `reprex`, solve some of your own problems, and submit even better bug reports!\n\n\n:::{.callout-tip collapse=\"true\"}\n## Expand for Session Info\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nâ”€ Session info â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n setting  value\n version  R version 4.1.1 (2021-08-10)\n os       macOS Monterey 12.2.1\n system   aarch64, darwin20\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       America/Chicago\n date     2022-04-25\n pandoc   2.18 @ /Applications/RStudio.app/Contents/MacOS/quarto/bin/tools/ (via rmarkdown)\n quarto   0.9.294 @ /usr/local/bin/quarto\n\nâ”€ Packages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n package     * version date (UTC) lib source\n dplyr       * 1.0.8   2022-02-08 [1] CRAN (R 4.1.1)\n espnscrapeR * 0.6.5   2021-10-27 [1] Github (jthomasmock/espnscrapeR@084ce80)\n forcats     * 0.5.1   2021-01-27 [1] CRAN (R 4.1.1)\n ggplot2     * 3.3.5   2021-06-25 [1] CRAN (R 4.1.1)\n purrr       * 0.3.4   2020-04-17 [1] CRAN (R 4.1.0)\n readr       * 2.0.2   2021-09-27 [1] CRAN (R 4.1.1)\n sessioninfo * 1.2.2   2021-12-06 [1] CRAN (R 4.1.1)\n slider      * 0.2.2   2021-07-01 [1] CRAN (R 4.1.0)\n stringr     * 1.4.0   2019-02-10 [1] CRAN (R 4.1.1)\n tibble      * 3.1.6   2021-11-07 [1] CRAN (R 4.1.1)\n tidyr       * 1.2.0   2022-02-01 [1] CRAN (R 4.1.1)\n tidyverse   * 1.3.1   2021-04-15 [1] CRAN (R 4.1.0)\n\n [1] /Library/Frameworks/R.framework/Versions/4.1-arm64/Resources/library\n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n```\n:::\n:::\n\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}