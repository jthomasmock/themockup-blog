{
  "hash": "cadf3123ff67e7b6eba8b61a948bb2d4",
  "result": {
    "markdown": "---\ntitle: \"Joins vs case whens - speed and memory tradeoffs\"\ndescription: |\n  Spoiler - joins are fastest, and can be easy to prep!\nauthor: Thomas Mock\ndate: 02-13-2021\nimage: preview.jpeg\ncategories:\n  - tidyverse\n  - data cleaning\n  - joins\n---\n\n\n\n# Matching names\n\nThere are many times where you may have a reference dataset that has some type of short-code, abbreviations, nicknames, or even misspellings. In this situation we want to create a new column or even overwrite the existing column with the correct spelling, the full name, etc. \n\nWhile there isn't a **wrong** way to do this, I've made mistakes in the past of making things more complicated for myself during data cleaning/prep steps. Most importantly to me in my data cleaning steps are \"speed of thought\" - aka how long it takes me to type out or reason through, but there are also tradeoffs in memory usage and in execution speed.\n\nI'm going to step through some strategies, honed by years of TidyTuesday data cleaning and prep!\n\n---\n\nIn general I want to preface all these examples with the fact that this exercise is easily translatable to various `join` options. Joins are great, but there are situations where the logicals aren't simple matches/index (like `x == \"val\"`) but rather more complex queries (like `x > 5 & var %in% c(\"val\", \"val2\")`), but I'm going to live within the constraints of my example use case. Also note that joins could join on more than one key or add as many variables as needed rather than just one, so there's additional complexity possible here.\n\n---\n\nTo avoid burying the lede, joins are by far the fastest and most memory-efficient method if you can fit your problem to that solution,  `data.table::fcase()` provides a easy to use and remarkably fast/memory-efficient intermediate method that works in base R, `data.tables` or `dplyr`, and `dplyr::case_when()` is the slowest/most-memory hungry for in-memory cases, BUT is probably fast enough for relatively small data (< 1,000,000 rows) and is the option that allows pushing compute into a remote backend via  `dbplyr`/`sparklyr`.\n\n---\n\n## Example Data\n\nWe're going to simulate a dataset with NFL team abbreviations and a \"stat\" that is relatively in scope with something like EPA, but again this is all simulated data.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\n# relatively nice sized dataset (100,000 rows)\nsample_size <- 100000\n\n# Get example team names from espn\nall_teams <- espnscrapeR::get_nfl_teams()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nGetting NFL teams!\n```\n:::\n\n```{.r .cell-code}\n# set a reproducible seed (h/t to Anthony's wife's new $4 luggage...)\nset.seed(829)\n\nex_df <- tibble(\n  team = sample(all_teams$team_abb, size = sample_size, replace = TRUE),\n  stat = rnorm(sample_size, mean = 0.1, sd = 0.1)\n)\n\nex_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 100,000 × 2\n   team     stat\n   <chr>   <dbl>\n 1 HOU    0.0593\n 2 JAX   -0.0534\n 3 DEN   -0.0488\n 4 NO    -0.0527\n 5 CAR    0.111 \n 6 CHI    0.132 \n 7 CAR    0.0481\n 8 IND    0.412 \n 9 HOU    0.0425\n10 ARI    0.200 \n# … with 99,990 more rows\n```\n:::\n:::\n\n## `dplyr::case_when()` solution\n\nThere's a fantastic function in the `dplyr` package called `case_when()`. \n\n[`case_when`](https://dplyr.tidyverse.org/reference/case_when.html):  \n\n> This function allows you to vectorise multiple if_else()  \n\nIn essence, this provides the ability to provide many logical statements to generate a specific outcome. You can read more about the syntax via: `?dplyr::case_when()` in the R console or the [docs](https://dplyr.tidyverse.org/reference/case_when.html). This functions works on vectors as well as in mutations inside data.frames/tibbles/data.tables. Lastly, it can also be translated into SQL automatically via `dbplyr` in situations where you don't want to bring all the data into memory.\n\n`case_when` is very readable to me, and feels better than a whole bundle of nested `ifelse`/`if_else` statements. \n\n---\n\nA quick `reprex` of `case_when()` usage.\n\n::: {.cell}\n\n```{.r .cell-code}\nex_car <- mpg %>% \n  select(model, cyl, cty, hwy) %>% \n  slice_sample(n = 100)\n\nex_car %>% \n  mutate(\n    cyl_character = case_when(\n      # if logical statement is TRUE then assign new value\n      cyl == 4 ~ \"Four\",\n      cyl == 6 ~ \"Six\",\n      cyl == 8 ~ \"Eight\",\n      # This last statement means, if none of the above conditions are met\n      # then return a NA value, note that case_when is type-safe\n      # so you'll want to use the various NA_??? for the type of output\n      TRUE ~ NA_character_\n    )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 100 × 5\n   model                 cyl   cty   hwy cyl_character\n   <chr>               <int> <int> <int> <chr>        \n 1 a4                      4    20    31 Four         \n 2 malibu                  4    22    30 Four         \n 3 ram 1500 pickup 4wd     8     9    12 Eight        \n 4 jetta                   5    21    29 <NA>         \n 5 passat                  4    18    29 Four         \n 6 camry solara            6    18    26 Six          \n 7 f150 pickup 4wd         8    13    16 Eight        \n 8 a4 quattro              6    17    25 Six          \n 9 grand cherokee 4wd      8    14    19 Eight        \n10 jetta                   4    22    29 Four         \n# … with 90 more rows\n```\n:::\n:::\n\n---\n\nNow that we understand the syntax a bit better, let's try it on our dataset of interest! Remember, we want to take our team abbreviations and add the team names into the dataset. So we'll need to provide a logical match of each `team` to the correct abbreviation and output the corresponding full name.\n\nThis works out very well and we got all the names in the right spot, and with the basic timing via `tictoc` we can see it was still fast. However, there's a LOT of typing, and more importantly a lot of repetitive typing to get this done.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tictoc)\n\ntic()\nex_df %>% \n    mutate(\n      team_name = case_when(\n        team == \"ARI\" ~ \"Cardinals\",\n        team == \"ATL\" ~ \"Falcons\",\n        team == \"BAL\" ~ \"Ravens\",\n        team == \"BUF\" ~ \"Bills\",\n        team == \"CAR\" ~ \"Panthers\",\n        team == \"CHI\" ~ \"Bears\",\n        team == \"CIN\" ~ \"Bengals\",\n        team == \"CLE\" ~ \"Browns\",\n        team == \"DAL\" ~ \"Cowboys\",\n        team == \"DEN\" ~ \"Broncos\",\n        team == \"DET\" ~ \"Lions\",\n        team == \"GB\" ~ \"Packers\",\n        team == \"HOU\" ~ \"Texans\",\n        team == \"IND\" ~ \"Colts\",\n        team == \"JAX\" ~ \"Jaguars\",\n        team == \"KC\" ~ \"Chiefs\",\n        team == \"LV\" ~ \"Raiders\",\n        team == \"LAC\" ~ \"Chargers\",\n        team == \"LAR\" ~ \"Rams\",\n        team == \"MIA\" ~ \"Dolphins\",\n        team == \"MIN\" ~ \"Vikings\",\n        team == \"NE\" ~ \"Patriots\",\n        team == \"NO\" ~ \"Saints\",\n        team == \"NYG\" ~ \"Giants\",\n        team == \"NYJ\" ~ \"Jets\",\n        team == \"PHI\" ~ \"Eagles\",\n        team == \"PIT\" ~ \"Steelers\",\n        team == \"SF\" ~ \"49ers\",\n        team == \"SEA\" ~ \"Seahawks\",\n        team == \"TB\" ~ \"Buccaneers\",\n        team == \"TEN\" ~ \"Titans\",\n        team == \"WSH\" ~ NA_character_,\n        TRUE ~ NA_character_\n      )\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 100,000 × 3\n   team     stat team_name\n   <chr>   <dbl> <chr>    \n 1 HOU    0.0593 Texans   \n 2 JAX   -0.0534 Jaguars  \n 3 DEN   -0.0488 Broncos  \n 4 NO    -0.0527 Saints   \n 5 CAR    0.111  Panthers \n 6 CHI    0.132  Bears    \n 7 CAR    0.0481 Panthers \n 8 IND    0.412  Colts    \n 9 HOU    0.0425 Texans   \n10 ARI    0.200  Cardinals\n# … with 99,990 more rows\n```\n:::\n\n```{.r .cell-code}\ntoc()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.064 sec elapsed\n```\n:::\n:::\n\nWe can use a few tricks in RStudio to make this easier!\n\nWe'll use \"multiple cursors\" in RStudio and combine that with the amazing [`{datapasta}`](https://github.com/MilesMcBain/datapasta) package from Miles McBain. \n\n> `datapasta` is about reducing resistance associated with copying and pasting data to and from R. It is a response to the realisation that I often found myself using intermediate programs like Sublime to munge text into suitable formats. Addins and functions in `datapasta` support a wide variety of input and output situations, so it (probably) \"just works\". Hopefully tools in this package will remove such intermediate steps and associated frustrations from our data slinging workflows.\n\n:::{.aside}\n\n`datapasta` is an absolute life saver for converting objects like vectors/dataframes/clipboard contents and turning them into editable formats in a script.\n\n:::\n\n### Step 1: `datapasta`\n\nWe'll first create a character vector via `datapasta`, using the below code:\n\n::: {.cell}\n\n```{.r .cell-code}\nex_df %>% \n  distinct(team) %>% \n  arrange(team) %>% \n  pull() %>% \n  datapasta::vector_paste_vertical()\n```\n:::\n\nI've shown a video of me stepping through this code since there are a lot of different options for `datapasta` and its outputs.\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/NH3anI8fPjA\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\nThis gives us a nice starting point of all the vector items and we are ready to work with them in our script.\n\n### Step 2: Multiple line selection in RStudio\n\nI've done this as a video as it's fairly complex to \"write about\", but very easy to show! The video describes the process of enabling multiple selections in RStudio. \n\nNote that the enabling multi-line selection is done in RStudio via:  \n\n- Opt key + Left Mouse Button drag on Mac  \n- Alt key + Left Mouse Button drag on Windows  \n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/9OgYTCzPqdE\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\nOnce we have this \"skeleton\" quickly created we can then add the individual \"match outputs\", like \"Cardinals\" for \"ARI\", \"Falcons\" for \"ATL\", etc, but we've saved ourself the need to type out a lot of the repeated \"skeleton\" of the `case_when()`.\n\n## A join solution\n\nWhile the above method is pretty quick to create and understand, we still had to type quite a bit (which is decreased if you use multiple cursors), and in many situations a true join is more efficient in terms of typing, \"speed of thought\", and execution time.\n\n::: {.cell}\n\n```{.r .cell-code}\nteam_join <- all_teams %>% \n  select(team_name, team = team_abb)\n\ntic()\nleft_join(ex_df, team_join, by = \"team\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 100,000 × 3\n   team     stat team_name\n   <chr>   <dbl> <chr>    \n 1 HOU    0.0593 Texans   \n 2 JAX   -0.0534 Jaguars  \n 3 DEN   -0.0488 Broncos  \n 4 NO    -0.0527 Saints   \n 5 CAR    0.111  Panthers \n 6 CHI    0.132  Bears    \n 7 CAR    0.0481 Panthers \n 8 IND    0.412  Colts    \n 9 HOU    0.0425 Texans   \n10 ARI    0.200  Cardinals\n# … with 99,990 more rows\n```\n:::\n\n```{.r .cell-code}\ntoc()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.013 sec elapsed\n```\n:::\n:::\n\nNow you may say, well of course I could just use a join if I have a perfect dataset, what do I do with data cleaning?! I would say that a while ago this was a revelation as I typically only would move to key-value pairs + joins when it was obvious, and sometimes I'd end up using a case when solution when a join was easily possible.\n\nSo, keep in mind that we can often \"create\" a joining dataset and use it pretty easily!\n\n### `tribble`\n\nWe can use [`tribble`](https://tibble.tidyverse.org/reference/tribble.html) to use almost the _exact_ same setup as the `case_when()`. We can even use the same multiple cursor workflow to take alter our existing `case_when()` code and turn it into the below `tribble` setup.\n\n::: {.cell}\n\n```{.r .cell-code}\ntribble(\n  ~team, ~team_name,\n  \"ARI\", \"Cardinals\",\n  \"ATL\", \"Falcons\",\n  \"BAL\", \"Ravens\",\n  \"BUF\", \"Bills\",\n  \"CAR\", \"Panthers\",\n  \"CHI\", \"Bears\",\n  \"CIN\", \"Bengals\",\n  \"CLE\", \"Browns\",\n  \"DAL\", \"Cowboys\",\n  \"DEN\", \"Broncos\",\n  \"DET\", \"Lions\",\n  \"GB\", \"Packers\",\n  \"HOU\", \"Texans\",\n  \"IND\", \"Colts\",\n  \"JAX\", \"Jaguars\",\n  \"KC\", \"Chiefs\",\n  \"LV\", \"Raiders\",\n  \"LAC\", \"Chargers\",\n  \"LAR\", \"Rams\",\n  \"MIA\", \"Dolphins\",\n  \"MIN\", \"Vikings\",\n  \"NE\", \"Patriots\",\n  \"NO\", \"Saints\",\n  \"NYG\", \"Giants\",\n  \"NYJ\", \"Jets\",\n  \"PHI\", \"Eagles\",\n  \"PIT\", \"Steelers\",\n  \"SF\", \"49ers\",\n  \"SEA\", \"Seahawks\",\n  \"TB\", \"Buccaneers\",\n  \"TEN\", \"Titans\",\n  \"WSH\", NA_character_\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 32 × 2\n   team  team_name\n   <chr> <chr>    \n 1 ARI   Cardinals\n 2 ATL   Falcons  \n 3 BAL   Ravens   \n 4 BUF   Bills    \n 5 CAR   Panthers \n 6 CHI   Bears    \n 7 CIN   Bengals  \n 8 CLE   Browns   \n 9 DAL   Cowboys  \n10 DEN   Broncos  \n# … with 22 more rows\n```\n:::\n:::\n\nYou could also just create a more traditional `data.frame`/`tibble`, and do the same thing without having to \"align\" all the rows visually. I _do_ find it a bit easier to look at it row-by-row in the `tribble` so that I can sanity check myself as I go, but up to the reader to decide!\n\n::: {.cell}\n\n```{.r .cell-code}\nex_df %>% \n  distinct(team) %>% \n  arrange(team) %>% \n  mutate(\n    team_name = \n      c(\n        \"Cardinals\", \"Falcons\", \"Ravens\", \"Bills\", \"Panthers\", \"Bears\", \n        \"Bengals\", \"Browns\", \"Cowboys\", \"Broncos\", \"Lions\", \"Packers\", \"Texans\", \n        \"Colts\", \"Jaguars\", \"Chiefs\", \"Raiders\", \"Chargers\", \"Rams\", \"Dolphins\", \n        \"Vikings\", \"Patriots\", \"Saints\", \"Giants\", \"Jets\", \"Eagles\", \"Steelers\", \n        \"49ers\", \"Seahawks\", \"Buccaneers\", \"Titans\", NA_character_\n    )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 32 × 2\n   team  team_name\n   <chr> <chr>    \n 1 ARI   Cardinals\n 2 ATL   Falcons  \n 3 BAL   Ravens   \n 4 BUF   Bills    \n 5 CAR   Panthers \n 6 CHI   Bears    \n 7 CIN   Bengals  \n 8 CLE   Browns   \n 9 DAL   Cowboys  \n10 DEN   Broncos  \n# … with 22 more rows\n```\n:::\n:::\n\n\n## `data.table::fcase`\n\nNow there is also an equivalent function to `case_when()` in `data.table` called [`fcase`](https://github.com/Rdatatable/data.table/issues/3823) (short for fast case when) as of late 2019. Since it operates on any vector, you can use it as a drop in replacement for most in-memory cases of `case_when()` in `dplyr`, or use it in native `data.table` objects. The expectation is that it will operate similarly in output but be more efficient with regards to memory/time.\n\n:::{.aside}\n\n`data.table` actually provides all sorts of cool optimized functions like this that work anywhere, and you can generally assume a \"f\" in front of an existing base R function name for the \"faster\" version of it. See `fifelse`, `rleid`, `fsetdiff` for example.\n\n:::\n\nNote, you do _not_ have the ability to push the translation of `fcase()` into SQL though, as `dbplyr` only has SQL-translation for `case_when()`.\n\nThe syntax of `fcase()` and `case_when()` are _essentially_ the same, but rather than a formula-syntax for assignment via `~`, it relies on another comma to assign by **position**.\n\nCompare the syntax below:  \n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(data.table)\n\nmtcars %>% \n  tibble() %>%\n  select(mpg, cyl) %>% \n  mutate(\n    cyl_case_when = case_when(\n      # relies on `~` to indicate assign\n      # read as if cyl is equal to 4 assign \"Four\"\n      cyl == 4 ~ \"Four\",\n      cyl == 6 ~ \"Six\",\n      cyl == 8 ~ \"Eight\",\n      TRUE ~ NA_character_\n    ),\n    cyl_fcase = fcase(\n      # relies on another `,` to assign by position\n      # reas as if cyl is equal to 4, \"Four\"\n      cyl == 4, \"Four\",\n      cyl == 6, \"Six\",\n      cyl == 8, \"Eight\",\n      TRUE, NA_character_\n    ),\n    cyl_match = cyl_case_when == cyl_fcase\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 32 × 5\n     mpg   cyl cyl_case_when cyl_fcase cyl_match\n   <dbl> <dbl> <chr>         <chr>     <lgl>    \n 1  21       6 Six           Six       TRUE     \n 2  21       6 Six           Six       TRUE     \n 3  22.8     4 Four          Four      TRUE     \n 4  21.4     6 Six           Six       TRUE     \n 5  18.7     8 Eight         Eight     TRUE     \n 6  18.1     6 Six           Six       TRUE     \n 7  14.3     8 Eight         Eight     TRUE     \n 8  24.4     4 Four          Four      TRUE     \n 9  22.8     4 Four          Four      TRUE     \n10  19.2     6 Six           Six       TRUE     \n# … with 22 more rows\n```\n:::\n:::\n\nNow, I have converted our example with the `case_when()` statement into `fcase()` for both `dplyr` and `data.table`, but have hidden the code in the detail box below since it's _almost_ identical and would be quite repetitive. I have printed a test to see if the outcomes are equivalent though between native `data.table` and `dplyr`, and they are! 🥳\n\nReally happy to have the option of using some various methods in-memory via `fcase()` and/or `case_when()` and optionally if working with REALLY large data push some of that compute into the database via `dbplyr` + `case_when()`.\n\n::: {.cell code_folding='true'}\n\n```{.r .cell-code}\ntic()\ndplyr_fcase <- ex_df %>% \n    mutate(\n      team_name = fcase(\n        team == \"ARI\", \"Cardinals\",\n        team == \"ATL\", \"Falcons\",\n        team == \"BAL\", \"Ravens\",\n        team == \"BUF\", \"Bills\",\n        team == \"CAR\", \"Panthers\",\n        team == \"CHI\", \"Bears\",\n        team == \"CIN\", \"Bengals\",\n        team == \"CLE\", \"Browns\",\n        team == \"DAL\", \"Cowboys\",\n        team == \"DEN\", \"Broncos\",\n        team == \"DET\", \"Lions\",\n        team == \"GB\" ,\"Packers\",\n        team == \"HOU\", \"Texans\",\n        team == \"IND\", \"Colts\",\n        team == \"JAX\", \"Jaguars\",\n        team == \"KC\" ,\"Chiefs\",\n        team == \"LV\" ,\"Raiders\",\n        team == \"LAC\", \"Chargers\",\n        team == \"LAR\", \"Rams\",\n        team == \"MIA\", \"Dolphins\",\n        team == \"MIN\", \"Vikings\",\n        team == \"NE\" ,\"Patriots\",\n        team == \"NO\" ,\"Saints\",\n        team == \"NYG\", \"Giants\",\n        team == \"NYJ\", \"Jets\",\n        team == \"PHI\", \"Eagles\",\n        team == \"PIT\", \"Steelers\",\n        team == \"SF\" ,\"49ers\",\n        team == \"SEA\", \"Seahawks\",\n        team == \"TB\" ,\"Buccaneers\",\n        team == \"TEN\", \"Titans\",\n        team == \"WSH\", NA_character_,\n        TRUE, NA_character_\n      )\n    )\ntoc()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.013 sec elapsed\n```\n:::\n\n```{.r .cell-code}\n# data.table native\ndt_fcase <- data.table(ex_df)[, team_name := fcase(\n    team == \"ARI\", \"Cardinals\",\n    team == \"ATL\", \"Falcons\",\n    team == \"BAL\", \"Ravens\",\n    team == \"BUF\", \"Bills\",\n    team == \"CAR\", \"Panthers\",\n    team == \"CHI\", \"Bears\",\n    team == \"CIN\", \"Bengals\",\n    team == \"CLE\", \"Browns\",\n    team == \"DAL\", \"Cowboys\",\n    team == \"DEN\", \"Broncos\",\n    team == \"DET\", \"Lions\",\n    team == \"GB\" ,\"Packers\",\n    team == \"HOU\", \"Texans\",\n    team == \"IND\", \"Colts\",\n    team == \"JAX\", \"Jaguars\",\n    team == \"KC\" ,\"Chiefs\",\n    team == \"LV\" ,\"Raiders\",\n    team == \"LAC\", \"Chargers\",\n    team == \"LAR\", \"Rams\",\n    team == \"MIA\", \"Dolphins\",\n    team == \"MIN\", \"Vikings\",\n    team == \"NE\" ,\"Patriots\",\n    team == \"NO\" ,\"Saints\",\n    team == \"NYG\", \"Giants\",\n    team == \"NYJ\", \"Jets\",\n    team == \"PHI\", \"Eagles\",\n    team == \"PIT\", \"Steelers\",\n    team == \"SF\" ,\"49ers\",\n    team == \"SEA\", \"Seahawks\",\n    team == \"TB\" ,\"Buccaneers\",\n    team == \"TEN\", \"Titans\",\n    team == \"WSH\", NA_character_,\n    TRUE, NA_character_\n  )] %>% \n    as_tibble()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nall_equal(dplyr_fcase, dt_fcase)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n# Speed and Memory\n\nI'm going to preface this by also saying that this is a particular straight forward problem to translate into a `join`, and it has 32 total comparisons. Most uses of `case_when()` or `fcase()` will be more traditional and/or complex logic problems and be much fewer than 30!!!\n\nNow with that being said, you may still say, well I'm not convinced that `join()` method is any easier or faster to code out for humans, and we're all free to make our own decisions! I do want to note that `case_when()` gets memory-inefficient much faster than `???_join()`.\n\nWe can really highlight the differences in the execution time and the memory allocated via the `{bench}` package. I'm using `bench` to execute the two different methods 3x time, compare the timing and the memory used, along with some other stats.\n\nIn the expandable section below we have a repeat of our above `left_join()` and `case_when()` calls.\n\n::: {.cell code_folding='true'}\n\n```{.r .cell-code}\njoin_expr <- function(){\n  left_join(ex_df, team_join, by = \"team\") %>% \n    slice(1)\n}\n\ncase_when_expr <- function(){\n  ex_df %>% \n    mutate(\n      team_name = case_when(\n        team == \"ARI\" ~ \"Cardinals\",\n        team == \"ATL\" ~ \"Falcons\",\n        team == \"BAL\" ~ \"Ravens\",\n        team == \"BUF\" ~ \"Bills\",\n        team == \"CAR\" ~ \"Panthers\",\n        team == \"CHI\" ~ \"Bears\",\n        team == \"CIN\" ~ \"Bengals\",\n        team == \"CLE\" ~ \"Browns\",\n        team == \"DAL\" ~ \"Cowboys\",\n        team == \"DEN\" ~ \"Broncos\",\n        team == \"DET\" ~ \"Lions\",\n        team == \"GB\" ~ \"Packers\",\n        team == \"HOU\" ~ \"Texans\",\n        team == \"IND\" ~ \"Colts\",\n        team == \"JAX\" ~ \"Jaguars\",\n        team == \"KC\" ~ \"Chiefs\",\n        team == \"LV\" ~ \"Raiders\",\n        team == \"LAC\" ~ \"Chargers\",\n        team == \"LAR\" ~ \"Rams\",\n        team == \"MIA\" ~ \"Dolphins\",\n        team == \"MIN\" ~ \"Vikings\",\n        team == \"NE\" ~ \"Patriots\",\n        team == \"NO\" ~ \"Saints\",\n        team == \"NYG\" ~ \"Giants\",\n        team == \"NYJ\" ~ \"Jets\",\n        team == \"PHI\" ~ \"Eagles\",\n        team == \"PIT\" ~ \"Steelers\",\n        team == \"SF\" ~ \"49ers\",\n        team == \"SEA\" ~ \"Seahawks\",\n        team == \"TB\" ~ \"Buccaneers\",\n        team == \"TEN\" ~ \"Titans\",\n        team == \"WSH\" ~ NA_character_,\n        TRUE ~ NA_character_\n      )\n    ) %>% slice(1)\n} \n```\n:::\n\nWe can then compare their execution multiple times with the `bench` package. This will vary by the execution, but with 3 iterations and 100,000 rows, I have seen about a 10x speed improvement in `left_join` vs `case_when`. Note that in most cases this is still pretty much instantaneous in \"human time\".\n\n:::{.aside}\n\nVisual reaction time in young adults is in the range of about 250 ms per [Jain et al](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4456887/).\n\n:::\n\nHowever, do note that we use about 28-30 times more memory for the `case_when()` statement.\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(\n  min_time = 0.1,\n  max_iterations = 3,\n  min_iterations = 3,\n  case_when_expr(),\n  join_expr()\n) %>% \n  select(expression, min, median, mem_alloc, n_itr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 4\n  expression            min   median mem_alloc\n  <bch:expr>       <bch:tm> <bch:tm> <bch:byt>\n1 case_when_expr()  57.31ms  98.29ms  150.82MB\n2 join_expr()        5.26ms   5.29ms    5.37MB\n```\n:::\n:::\n\nThe 150 Mb of memory used, may not seem like a lot with smaller datasets (100,000), but if we were to bump this up to 1,000,000 rows we see a similar 10x increase of memory. Specifically we are now up to ~1.5 Gb of memory used for `case_when()`. So if you're going beyond the millions or 10s of millions of rows AND are trying to do a LOT of comparisons, probably a good idea to start refactoring into a `join` if possible!\n\n::: {.cell code_folding='true'}\n\n```{.r .cell-code}\n# 1,000,000 rows as 1e6\nsample_size <- 1e6\n\nset.seed(829)\n\nex_df <- tibble(\n  team = sample(all_teams$team_abb, size = sample_size, replace = TRUE),\n  stat = rnorm(sample_size, mean = 0.1, sd = 0.1)\n)\n\nbench::mark(\n  min_time = 0.1,\n  max_iterations = 3,\n  min_iterations = 3,\n  case_when_expr(),\n  join_expr()\n) %>% \n  select(expression, min, median, mem_alloc, n_itr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 4\n  expression            min   median mem_alloc\n  <bch:expr>       <bch:tm> <bch:tm> <bch:byt>\n1 case_when_expr()  511.3ms  515.5ms    1.47GB\n2 join_expr()        44.9ms   46.2ms   53.43MB\n```\n:::\n:::\n\nThere are situations where a `join` doesn't solve the problem, so we can go one step further and add in our `data.table::fcase()` or `dtplyr`-translation of `dplyr` into `data.table`. All the example reprex code is in an expandable chunk below.\n\n::: {.cell code_folding='true'}\n\n```{.r .cell-code}\nlibrary(dtplyr)\n\ncase_when_dplyr <- function(){\n  ex_df %>% \n    mutate(\n      team_name = case_when(\n        team == \"ARI\" ~ \"Cardinals\",\n        team == \"ATL\" ~ \"Falcons\",\n        team == \"BAL\" ~ \"Ravens\",\n        team == \"BUF\" ~ \"Bills\",\n        team == \"CAR\" ~ \"Panthers\",\n        team == \"CHI\" ~ \"Bears\",\n        team == \"CIN\" ~ \"Bengals\",\n        team == \"CLE\" ~ \"Browns\",\n        team == \"DAL\" ~ \"Cowboys\",\n        team == \"DEN\" ~ \"Broncos\",\n        team == \"DET\" ~ \"Lions\",\n        team == \"GB\" ~ \"Packers\",\n        team == \"HOU\" ~ \"Texans\",\n        team == \"IND\" ~ \"Colts\",\n        team == \"JAX\" ~ \"Jaguars\",\n        team == \"KC\" ~ \"Chiefs\",\n        team == \"LV\" ~ \"Raiders\",\n        team == \"LAC\" ~ \"Chargers\",\n        team == \"LAR\" ~ \"Rams\",\n        team == \"MIA\" ~ \"Dolphins\",\n        team == \"MIN\" ~ \"Vikings\",\n        team == \"NE\" ~ \"Patriots\",\n        team == \"NO\" ~ \"Saints\",\n        team == \"NYG\" ~ \"Giants\",\n        team == \"NYJ\" ~ \"Jets\",\n        team == \"PHI\" ~ \"Eagles\",\n        team == \"PIT\" ~ \"Steelers\",\n        team == \"SF\" ~ \"49ers\",\n        team == \"SEA\" ~ \"Seahawks\",\n        team == \"TB\" ~ \"Buccaneers\",\n        team == \"TEN\" ~ \"Titans\",\n        team == \"WSH\" ~ NA_character_,\n        TRUE ~ NA_character_\n      )\n    )\n} \n\n\njoin_dplyr <- function(){\n  left_join(ex_df, team_join, by = \"team\")\n}\n\njoin_dtplyr <- function(){\n  dt_ex_df <- lazy_dt(ex_df)\n  team_join <- lazy_dt(team_join)\n    \n  dt_ex_df %>% \n    left_join(team_join, by = \"team\") %>% \n    select(team, stat, team_name) %>% \n    as_tibble() \n}\n\ncase_when_dtplyr <- function(){\n  lazy_dt(ex_df) %>% \n    mutate(\n      team_name = case_when(\n        team == \"ARI\" ~ \"Cardinals\",\n        team == \"ATL\" ~ \"Falcons\",\n        team == \"BAL\" ~ \"Ravens\",\n        team == \"BUF\" ~ \"Bills\",\n        team == \"CAR\" ~ \"Panthers\",\n        team == \"CHI\" ~ \"Bears\",\n        team == \"CIN\" ~ \"Bengals\",\n        team == \"CLE\" ~ \"Browns\",\n        team == \"DAL\" ~ \"Cowboys\",\n        team == \"DEN\" ~ \"Broncos\",\n        team == \"DET\" ~ \"Lions\",\n        team == \"GB\" ~ \"Packers\",\n        team == \"HOU\" ~ \"Texans\",\n        team == \"IND\" ~ \"Colts\",\n        team == \"JAX\" ~ \"Jaguars\",\n        team == \"KC\" ~ \"Chiefs\",\n        team == \"LV\" ~ \"Raiders\",\n        team == \"LAC\" ~ \"Chargers\",\n        team == \"LAR\" ~ \"Rams\",\n        team == \"MIA\" ~ \"Dolphins\",\n        team == \"MIN\" ~ \"Vikings\",\n        team == \"NE\" ~ \"Patriots\",\n        team == \"NO\" ~ \"Saints\",\n        team == \"NYG\" ~ \"Giants\",\n        team == \"NYJ\" ~ \"Jets\",\n        team == \"PHI\" ~ \"Eagles\",\n        team == \"PIT\" ~ \"Steelers\",\n        team == \"SF\" ~ \"49ers\",\n        team == \"SEA\" ~ \"Seahawks\",\n        team == \"TB\" ~ \"Buccaneers\",\n        team == \"TEN\" ~ \"Titans\",\n        team == \"WSH\" ~ NA_character_,\n        TRUE ~ NA_character_\n      )\n    ) %>% \n    as_tibble()\n  \n}\n\nfcase_dplyr <- function(){\n  ex_df %>% \n    mutate(\n      team_name = fcase(\n        team == \"ARI\", \"Cardinals\",\n        team == \"ATL\", \"Falcons\",\n        team == \"BAL\", \"Ravens\",\n        team == \"BUF\", \"Bills\",\n        team == \"CAR\", \"Panthers\",\n        team == \"CHI\", \"Bears\",\n        team == \"CIN\", \"Bengals\",\n        team == \"CLE\", \"Browns\",\n        team == \"DAL\", \"Cowboys\",\n        team == \"DEN\", \"Broncos\",\n        team == \"DET\", \"Lions\",\n        team == \"GB\" ,\"Packers\",\n        team == \"HOU\", \"Texans\",\n        team == \"IND\", \"Colts\",\n        team == \"JAX\", \"Jaguars\",\n        team == \"KC\" ,\"Chiefs\",\n        team == \"LV\" ,\"Raiders\",\n        team == \"LAC\", \"Chargers\",\n        team == \"LAR\", \"Rams\",\n        team == \"MIA\", \"Dolphins\",\n        team == \"MIN\", \"Vikings\",\n        team == \"NE\" ,\"Patriots\",\n        team == \"NO\" ,\"Saints\",\n        team == \"NYG\", \"Giants\",\n        team == \"NYJ\", \"Jets\",\n        team == \"PHI\", \"Eagles\",\n        team == \"PIT\", \"Steelers\",\n        team == \"SF\" ,\"49ers\",\n        team == \"SEA\", \"Seahawks\",\n        team == \"TB\" ,\"Buccaneers\",\n        team == \"TEN\", \"Titans\",\n        team == \"WSH\", NA_character_\n      )\n    )\n}\n  \n\nfcase_dt_native <- function(){\n  data.table(ex_df)[, team_name := fcase(\n    team == \"ARI\", \"Cardinals\",\n    team == \"ATL\", \"Falcons\",\n    team == \"BAL\", \"Ravens\",\n    team == \"BUF\", \"Bills\",\n    team == \"CAR\", \"Panthers\",\n    team == \"CHI\", \"Bears\",\n    team == \"CIN\", \"Bengals\",\n    team == \"CLE\", \"Browns\",\n    team == \"DAL\", \"Cowboys\",\n    team == \"DEN\", \"Broncos\",\n    team == \"DET\", \"Lions\",\n    team == \"GB\" ,\"Packers\",\n    team == \"HOU\", \"Texans\",\n    team == \"IND\", \"Colts\",\n    team == \"JAX\", \"Jaguars\",\n    team == \"KC\" ,\"Chiefs\",\n    team == \"LV\" ,\"Raiders\",\n    team == \"LAC\", \"Chargers\",\n    team == \"LAR\", \"Rams\",\n    team == \"MIA\", \"Dolphins\",\n    team == \"MIN\", \"Vikings\",\n    team == \"NE\" ,\"Patriots\",\n    team == \"NO\" ,\"Saints\",\n    team == \"NYG\", \"Giants\",\n    team == \"NYJ\", \"Jets\",\n    team == \"PHI\", \"Eagles\",\n    team == \"PIT\", \"Steelers\",\n    team == \"SF\" ,\"49ers\",\n    team == \"SEA\", \"Seahawks\",\n    team == \"TB\" ,\"Buccaneers\",\n    team == \"TEN\", \"Titans\",\n    team == \"WSH\", NA_character_\n  )] %>% \n    as_tibble()\n}\n\njoin_dt_native <- function(){\n  data.table(ex_df)[data.table(team_join), on = .(team), team_name := team_name] %>% \n    as_tibble()\n}\n```\n:::\n\nFinally we can check the timing/memory usage for all of the combos. In short, `join()`-methods are fastest and use the least memory, `fcase()` whether in native `data.table` or `dplyr` is a bit slower/more memory than `join` but still ~5x faster/more memory efficient than `case_when()`, and `case_when()` is the slowest/most memory hungry (but translates into SQL if needed).\n\nOverall, I'm really happy that we have the ability to mix and match functions from various awesome packages depending on the problems we're trying to solve!\n\n::: {.cell code_folding='true' hash='joins-vs-casewhen-speed-and-memory-tradeoffs_cache/html/unnamed-chunk-15_4b02ec65efd4af3ed53b5abe6d54db6e'}\n\n```{.r .cell-code}\nbench::mark(\n  min_time = 0.1,\n  max_iterations = 3,\n  min_iterations = 3,\n  case_when_dplyr(),\n  case_when_dtplyr(),\n  fcase_dplyr(),\n  fcase_dt_native(),\n  join_dplyr(),\n  join_dt_native(),\n  check = FALSE\n) %>% \n  select(expression, min, median, mem_alloc, n_itr)\n```\n\n::: {.cell-output-stdout}\n```\n# A tibble: 6 × 4\n  expression              min   median mem_alloc\n  <bch:expr>         <bch:tm> <bch:tm> <bch:byt>\n1 case_when_dplyr()   500.5ms  513.1ms    1.47GB\n2 case_when_dtplyr()  119.1ms  120.9ms  164.96MB\n3 fcase_dplyr()         114ms  120.2ms  133.72MB\n4 fcase_dt_native()   116.2ms  117.3ms   164.4MB\n5 join_dplyr()         43.9ms   45.3ms   53.43MB\n6 join_dt_native()     27.8ms   31.1ms   61.63MB\n```\n:::\n:::\n\n:::{.callout-tip collapse=\"true\"}\n## Expand for Session Info\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.1.1 (2021-08-10)\n os       macOS Monterey 12.2.1\n system   aarch64, darwin20\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       America/Chicago\n date     2022-04-25\n pandoc   2.18 @ /Applications/RStudio.app/Contents/MacOS/quarto/bin/tools/ (via rmarkdown)\n quarto   0.9.294 @ /usr/local/bin/quarto\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n bench       * 1.1.2   2021-11-30 [1] CRAN (R 4.1.1)\n data.table  * 1.14.2  2021-09-27 [1] CRAN (R 4.1.1)\n datapasta   * 3.1.1   2021-10-27 [1] Github (MilesMcBain/datapasta@69d2a69)\n dplyr       * 1.0.8   2022-02-08 [1] CRAN (R 4.1.1)\n dtplyr      * 1.1.0   2021-02-20 [1] CRAN (R 4.1.0)\n espnscrapeR * 0.6.5   2021-10-27 [1] Github (jthomasmock/espnscrapeR@084ce80)\n forcats     * 0.5.1   2021-01-27 [1] CRAN (R 4.1.1)\n ggplot2     * 3.3.5   2021-06-25 [1] CRAN (R 4.1.1)\n purrr       * 0.3.4   2020-04-17 [1] CRAN (R 4.1.0)\n readr       * 2.0.2   2021-09-27 [1] CRAN (R 4.1.1)\n sessioninfo * 1.2.2   2021-12-06 [1] CRAN (R 4.1.1)\n stringr     * 1.4.0   2019-02-10 [1] CRAN (R 4.1.1)\n tibble      * 3.1.6   2021-11-07 [1] CRAN (R 4.1.1)\n tictoc      * 1.0.1   2021-04-19 [1] CRAN (R 4.1.0)\n tidyr       * 1.2.0   2022-02-01 [1] CRAN (R 4.1.1)\n tidyverse   * 1.3.1   2021-04-15 [1] CRAN (R 4.1.0)\n\n [1] /Library/Frameworks/R.framework/Versions/4.1-arm64/Resources/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n:::\n:::\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}