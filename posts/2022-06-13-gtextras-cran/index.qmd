---
title: "Beautiful tables in R with gtExtras"
description: |
  Merging static tables with graphics is a powerful combo
author: Thomas Mock
date: 2022-06-13
categories:
  - gt
  - tables
image: "https://raw.githubusercontent.com/jthomasmock/themockup-blog/master/posts/2022-06-13-gtextras-cran/preview.png"
image-alt: "The hex logo for gtExtras, it is primarily a pixel-art inspired table with a computer, a gin and tonic cocktail, and a small cactus on top, below the desk is a small boston terrier."
twitter-card:
  image: "https://raw.githubusercontent.com/jthomasmock/themockup-blog/master/posts/2022-06-13-gtextras-cran/preview.png"
  image-alt: "The hex logo for gtExtras, it is primarily a pixel-art inspired table with a computer, a gin and tonic cocktail, and a small cactus on top, below the desk is a small boston terrier."
---

```{r, include=FALSE}
library(tidyverse)
library(gt)
library(gtExtras)
```


I'm very excited to have the first release of `gtExtras` available on CRAN!

The goal of `gtExtras` is to provide opinionated helper functions to assist in creating beautiful and functional tables with `gt`.

The functions are generally wrappers around boilerplate table-making code or adding opinionated functions like data journalism inspired table themes and inline graphics. The [`gt` package](https://gt.rstudio.com/) is amazing, make sure to go read the official documentation.

For installation:

```{r, eval = FALSE}
install.packages("gtExtras")
# or if wanting the dev version
# if needed install.packages("remotes")
remotes::install_github("jthomasmock/gtExtras")
```

## Using `gtExtras`

Overall, there are a lot of available functions in `gtExtras`:

```{r}
length(ls.str('package:gtExtras', mode='function'))
```

You can read about each of the functions in the [function
reference](https://jthomasmock.github.io/gtExtras/reference/index.html).

Overall, there are four families of functions in `gtExtras`:

-   Themes: 7 themes that style almost every element of a `gt` table,
    built off of data journalism-styled tables
-   Utilities: Helper functions for aligning/padding numbers, adding
    `fontawesome` icons, images, highlighting, dividers, styling by
    group, creating two tables or two column layouts, extracting ordered
    data from a `gt` table internals, or generating a random dataset for
    `reprex`
-   Plotting: 12 plotting functions for inline sparklines, win-loss
    charts, distributions (density/histogram), percentiles, dot + bar,
    bar charts, confidence intervals, or summarizing an entire
    dataframe!
-   Colors: 3 functions, a palette for “Hulk” style scale (purple/green), coloring rows with good defaults from `paletteer`, or adding a “color box” along with the cell value

Also see the [Plotting with `gtExtras`
article](https://jthomasmock.github.io/gtExtras/articles/plotting-with-gtExtras.html)
for more examples of combining tables and graphics together.

A subset of functions are included below, or see the full [function
reference](https://jthomasmock.github.io/gtExtras/reference/index.html).

Importantly, `gtExtras` is not at all a replacement for `gt`, but rather is almost a "cookbook" where common or repeated function calls are grouped into their own respective functions. At a technical level, `gtExtras` is literally just `gt` functions under the hood and I'll highlight a few examples of how to do the same thing in each package. 

### Load libraries

```{r}
library(tidyverse)
library(gt)
library(gtExtras)
```

### Themes

The package includes seven different themes, and 3 examples are the
`gt_theme_538()` styled after FiveThirtyEight style tables, the
`gt_theme_espn()` styled after ESPN style tables, and the
`gt_theme_nytimes()` styled after The New York Times tables.

```{r}
head(mtcars) %>%
  gt() %>% 
  gt_theme_538() %>% 
  tab_header(title = "Table styled like the FiveThirtyEight")
```


```{r}
head(mtcars) %>%
  gt() %>% 
  gt_theme_guardian() %>% 
  tab_header(title = "Table styled like the Guardian")
```


```{r}
head(mtcars) %>% 
  gt() %>% 
  gt_theme_nytimes() %>% 
  tab_header(title = "Table styled like the NY Times")
```

There are also themes that are bit more specific or somewhat "tongue in cheek":

```{r}
head(mtcars) %>% 
  gt() %>% 
  gt_theme_excel() %>% 
  tab_header(title = "Table styled like Excel")
```

```{r}
head(mtcars) %>% 
  gt() %>% 
  gt_theme_dot_matrix() %>% 
  tab_header(title = "Table styled like a dot matrix printer")
```

If you wanted to write your own `gt_theme_YOURTHEME()` function, you could do this with something like the below:

```{r}
my_theme <- function(gt_object, ...){
  gt_object %>%
    tab_options(
      column_labels.background.color = "black",
      heading.align = "left",
      ...
    ) %>%
    tab_style(
      style = cell_text(color = "red", size = px(32)),
      locations = cells_title("title")
    )
}

```

```{r}
head(mtcars) %>%
  gt() %>%
  my_theme() %>%
  tab_header("My own custom theme!")
```


### Hulk data_color

This is an opinionated diverging color palette. It diverges from low to
high as purple to green. It is a good alternative to a red-green
diverging palette as a color-blind friendly palette. The specific colors
come from
[colorbrewer2](https://colorbrewer2.org/#type=diverging&scheme=PRGn&n=7).

Basic usage below, where a specific column is passed.

```{r}
# basic use
head(mtcars) %>%
  gt::gt() %>%
  gt_hulk_col_numeric(mpg)
```


Trim provides a tighter range of purple/green so the colors are less
pronounced.

```{r}
head(mtcars) %>%
  gt::gt() %>%
  # trim gives smaller range of colors
  # so the green and purples are not as dark
  gt_hulk_col_numeric(mpg:disp, trim = TRUE) 
```


Reverse makes higher values represented by purple and lower by green.
The default is to have high = green, low = purple.

```{r}
# option to reverse the color palette
# so that purple is higher
head(mtcars) %>%
  gt::gt() %>%
  # reverse = green for low, purple for high
  gt_hulk_col_numeric(mpg:disp, reverse = TRUE) 
```

### `gt_color_rows()`

The `gt_color_rows()` function is a more generic, thin boilerplate wrapper around `gt::data_color()`. A quick example of `gt::data_color()` is below.

Using named colors or hex colors is very simple!

```{r}
head(mtcars) %>% 
  gt() %>% 
  gt::data_color(
    columns = mpg:disp, colors = c("white", "red")
  )
```

Some complexity arises when wanting to use a color palette with tighter control. The code below is good but requires you to write out a lot of your own control.

```{r}

color_fn <- scales::col_numeric(
    domain = NULL,
  palette = as.character(
    paletteer::paletteer_d(
      palette = "ggsci::red_material" ,
      type = "continuous"))
  )

head(mtcars) %>% 
  gt() %>% 
  gt::data_color(columns = mpg:disp, colors = color_fn)
```


`gtExtras::gt_color_rows()` simple to use but provides rich color
choices thanks to the native inclusion of `paletteer::paletteer_d()`. This can provide 100s of discrete (ie categorical) or continuous color palettes. 

Note that it is very close to the `color_fn` from above but throws a warning if domain is NULL since that will use range within EACH column rather than a shared range ACROSS columns.


```{r}
# basic use
mtcars %>%
  head() %>%
  gt() %>%
  gt_color_rows(mpg:disp)
```

You can change the specific palette with
`palette = "package_name::palette_name"`

```{r}
# recognizes all of the dynamic palettes from paletteer
mtcars %>%
  head() %>%
  gt() %>%
  gt_color_rows(mpg:disp, palette = "ggsci::blue_material")
```


You can also use custom-defined palettes with named colors in R or hex
color values however, this has minimal value over `gt::data_color()`. The main difference would be ability to specify a domain and throwing a warning without it.

```{r}
mtcars %>%
  head() %>%
  gt() %>%
  gt_color_rows(mpg:disp, palette = c("white", "green"))
    # could also use palette = c("#ffffff", "##00FF00")
```

`gt`-native example gives you basically the same result.

```{r}
mtcars %>%
  head() %>%
  gt() %>%
  gt::data_color(mpg:disp, colors = c("white", "green"))
```

Lastly, you can also provide categorical or discrete data to be colored.

```{r}
# provide type = "discrete"
mtcars %>%
  head() %>%
  gt() %>%
  gt_color_rows(
    cyl, 
    palette = "ggthemes::colorblind", 
    # note that you can manually define range like c(4, 6, 8)
    domain = range(mtcars$cyl),
    pal_type = "discrete"
   )
```

Again, this function is an example of something that is easily possible with `gt` but would require a good chunk of repeated boilerplate code.

### `gt_highlight_rows()`

This provides the ability to highlight and optionally bold entire rows
within an existing `gt` table. Basic use defaults to a light-blue
highlight which can be changed with the `fill` argument.

```{r}
head_car <- head(mtcars[,1:5]) %>% 
  tibble::rownames_to_column("car")

gt(head_car) %>% 
  gt_highlight_rows(rows = 2, font_weight = "normal") 
```

You can optionally specify a target column with `target_col` that will
be bold, while the rest of the row’s text will be default weight.

```{r}
gt(head_car) %>% 
  gt_highlight_rows(
    rows = 5, 
    fill = "lightgrey",
    bold_target_only = TRUE,
    target_col = car
    )
```

And because `gtExtras` is _just_ using `gt::tab_style()` under the hood, it also accepts logical statements for specific rows.

```{r}
gt(head_car) %>% 
  gt_highlight_rows(
    rows = drat == 3.08,# a logic statement
    fill = "lightgrey",
    bold_target_only = TRUE,
    target_col = car
    )
```

The equivalent `gt` code - again, easy to figure out but some repeated calls.

```{r}
gt(head_car) %>%
  tab_style(
    style = cell_fill(color = "lightgrey"), 
    locations = cells_body(everything(), rows = drat == 3.08)
    ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_body(car, rows = drat == 3.08)
  )
```

## Plotting in `gt` with `gtExtras`

As we get into plotting with `gt` the complexity really ramps up internally, as you're wrapping `gt` + `ggplot2` code internally.

Note that if you just want to create `ggplot2` plots and embed them in `gt`, you can use `gt::ggplot_image()`! That gives you full and separate control of the two items, ie just use `ggplot2` and use `gt` separately. 

```{r}
plot_object <-
  ggplot(
    data = gtcars,
    aes(x = hp, y = trq, size = msrp)
  ) +
  geom_point(color = "blue") +
  theme(legend.position = "none")

dplyr::tibble(
  text = "Here is a ggplot:",
  ggplot = NA
) %>%
  gt() %>%
  text_transform(
    locations = cells_body(columns = ggplot),
    fn = function(x) {
      plot_object %>%
        ggplot_image(height = px(200))
    }
  )
```

However, with the plotting functions in `gtExtras`, I've made some opinionated choices as to the output style/size/options - taking away some of your creativity for a simple to use user interface.

A side effect of these `gtExtras` functions is that almost exclusively they require you to pass datasets with list columns. These are easy enough to create!

```{r}
mtcars %>%
   dplyr::group_by(cyl) %>%
   # must end up with list of data for each row in the input dataframe
   dplyr::summarize(mpg_data = list(mpg), .groups = "drop")
```


### `gt_sparkline()`

A typical sparkline for your table!

```{r}
mtcars %>%
   dplyr::group_by(cyl) %>%
   # must end up with list of data for each row in the input dataframe
   dplyr::summarize(mpg_data = list(mpg), .groups = "drop") %>%
   gt() %>%
   gt_plt_sparkline(mpg_data)
```

### `gt_plt_dist()`

If you'd rather plot some distributions, you could use `gt_plt_dist()`. This functions defaults to an inline density plot, but accepts a type = `"boxplot"`, `"histogram"`, `"rug_strip"` or `"density"`.

```{r}
mtcars %>%
   dplyr::group_by(cyl) %>%
   # must end up with list of data for each row in the input dataframe
   dplyr::summarize(mpg_data = list(mpg), .groups = "drop") %>%
   gt() %>%
   gt_plt_dist(mpg_data)
```


### `gt_bar_plot()`

The `gt_bar_plot` function takes an existing `gt_tbl` object and adds
horizontal barplots via native HTML. This is a wrapper around raw HTML
strings, `gt::text_transform()` and `gt::cols_align()`. Note that values
default to being normalized to the percent of the maximum observed value
in the specified column. You can turn this off if the values already
represent a percentage value representing 0-100.

```{r}
mtcars %>%
  head() %>%
  dplyr::select(cyl, mpg) %>%
  dplyr::mutate(mpg_pct_max = round(mpg/max(mpg) * 100, digits = 2),
                mpg_scaled = mpg/max(mpg) * 100) %>%
  dplyr::mutate(mpg_unscaled = mpg) %>%
  gt() %>%
  gt_plt_bar_pct(column = mpg_scaled, scaled = TRUE) %>%
  gt_plt_bar_pct(column = mpg_unscaled, scaled = FALSE, fill = "blue", background = "lightblue") %>%
  cols_align("center", contains("scale")) %>%
  cols_width(4 ~ px(125),
             5 ~ px(125))
```

### `gt_merge_stack()`

The `gt_merge_stack()` function takes an existing `gt` table and merges
column 1 and column 2, stacking column 1’s text on top of column 2’s.
Top text is in all caps with black bold text, while the lower text is
smaller and dark grey.

Note that `team_nick` has the team nickname over the team's division.

```{r}
team_df <- readRDS(url("https://github.com/nflverse/nflfastR-data/raw/master/teams_colors_logos.rds"))

team_df %>%
  dplyr::select(team_nick, team_abbr, team_conf, team_division, team_wordmark) %>%
  head(8) %>%
  gt(groupname_col = "team_conf") %>%
  gt_merge_stack(col1 = team_nick, col2 = team_division) %>%
  gt_img_rows(team_wordmark)
```

### `gt_plt_winloss()`

This function takes a list-column of win loss values (ie, 0=loss, 0.5 =
tie, 1 = win) and ouputs an inline plot representing the win/loss
squares with blue = win, red = loss, grey = tie. Points are also also
redundantly coded with height, where wins are highest, ties are middle,
and losses are at the bottom.

The example below generates an example dataset and then embeds a plot.

```{r}
create_input_df <- function(repeats = 3){
  
  input_df <- dplyr::tibble(
    team = c("A1", "B2", "C3", "C4"),
    Wins = c(3, 2, 1, 1),
    Losses = c(2, 3, 2, 4),
    Ties = c(0, 0, 2, 0),
    outcomes = list(
      c(1, .5, 0) %>% rep(each = repeats),
      c(0, 1, 0.5) %>% rep(each = repeats),
      c(0, 0.5, 1) %>% rep(each = repeats),
      c(0.5, 1, 0) %>% rep(each = repeats)
    )
  )
  
  input_df
  
}

create_input_df(5) %>% 
  dplyr::glimpse()
```


Now that we have way to quickly generate example data, we can show the
ability to incrementally add the win/losses.

Starting with 3 games. **Please ignore the Wins/Loss/Ties columns**, as
they are simply placeholders. I am iterating the length of the outcomes
list row.

```{r}
create_input_df(1) %>% 
  gt() %>% 
  gt_plt_winloss(outcomes, max_wins = 15) %>% 
  tab_options(data_row.padding = px(2))
```

And moving to 12 games, we can see that the scale is unchanged, and
“empty” points are replaced with outcomes once the values are present in
the data.

```{r}
create_input_df(4) %>% 
  gt() %>% 
  gt_plt_winloss(outcomes, max_wins = 15) %>% 
  tab_options(data_row.padding = px(2))
```


You can also switch over to ‘squares’ instead of ‘pills’ by changing the
`type` argument.

```{r}
create_input_df(4) %>% 
  gt() %>% 
  gt_plt_winloss(outcomes, max_wins = 15, type = "square") %>% 
  tab_options(data_row.padding = px(2))
```


A more realistic use case is seen below with data from `{nflreadr}`:

<details><summary>Creating dataset</summary>

```{r}
library(dplyr)
library(tidyr)
library(nflreadr)

games_df <- nflreadr::load_schedules() %>% 
  filter(season == 2020, game_type == "REG") %>% 
  select(game_id, team_home = home_team, team_away = away_team, result, week) %>% 
  pivot_longer(contains('team'), names_to = 'home_away', values_to = 'team', names_prefix = 'team_') %>% 
  mutate(
    result = ifelse(home_away == 'home', result, -result),
    win = ifelse(result == 0 , 0.5, ifelse(result > 0, 1, 0))
  ) %>% 
  select(week, team, win) %>% 
  mutate(
    team = case_when(
      team == 'STL' ~ 'LA',
      team == 'OAK' ~ 'LV',
      team == 'SD' ~ 'LAC',
      T ~ team
    )
  )

team_df <- nflreadr::load_teams() %>% 
  select(team_wordmark, team_abbr, team_conf, team_division)

joined_df <- games_df %>% 
  group_by(team) %>% 
  summarise(
    Wins = length(win[win==1]),
    Losses = length(win[win==0]),
    outcomes = list(win), .groups = "drop") %>% 
  left_join(team_df, by = c("team" = "team_abbr")) %>% 
  select(team_wordmark, team_conf, team_division, Wins:outcomes)

final_df <- joined_df %>% 
  filter(team_conf == "AFC") %>% 
  group_by(team_division) %>% 
  arrange(desc(Wins)) %>% 
  ungroup() %>% 
  arrange(team_division)
```

</details>

```{r}
final_df %>% 
  gt(groupname_col = "team_division") %>%
  gt_plt_winloss(outcomes, max_wins = 16) %>% 
  gt_img_rows(columns = team_wordmark) %>% 
  gt_theme_538() %>% 
  tab_header(title = "2020 Results by Division for the AFC")
```


## Closing

So that has been a brief overview of some of the possibilities of `gtExtras` - so go out, use `gt`, bring in `gtExtras` when you'd like to extend some of the work you're doing and let me know if you enjoy the package!

```{r, echo=FALSE, child="/Users/thomasmock/themockup-blog/_R/footer.qmd"}
```
